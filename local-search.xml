<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>nginx编译安装</title>
    <link href="/2023/09/30/nginx-install/"/>
    <url>/2023/09/30/nginx-install/</url>
    
    <content type="html"><![CDATA[<p class="note note-warning">一：在nginx官网下载Linux安装包<p><ul><li><p>进入<a href="https://nginx.org/">https://nginx.org/</a> 找到你想要的版本，并下载,我这里选择的是 <span class="note note-success">nginx-1.21.6.tar.gz<span></p></li><li><p>通过Xftp上传到你的CentOS服务器</p></li></ul><p class="note note-warning">二：解压缩安装包<p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">tar -zxvf nginx-1.21.6.tar.gz<br></code></pre></td></tr></table></figure><p class="note note-warning">三：编译安装<p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd nginx-1.21.6<br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-built_in">ls</span> 可以看到里面有个configure文件，这是一个安装脚本</span><br>./configure --prefix=/usr/local/nginx # --prefix是指定安装在哪个目录下<br><span class="hljs-meta prompt_">#</span><span class="language-bash">执行发现报错</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">1.缺少C语言编译器</span><br>yum install -y gcc<br><span class="hljs-meta prompt_">#</span><span class="language-bash">2.缺少pcre库</span><br>yum install -y pcre pcre-devel<br><span class="hljs-meta prompt_">#</span><span class="language-bash">3.缺少zlib库</span><br>yum install -y zlib zlib-devel<br><span class="hljs-meta prompt_">#</span><span class="language-bash">编译</span><br>make &amp;&amp; make install<br></code></pre></td></tr></table></figure><p class="note note-warning">四：启动nginx<p><ul><li><p>进入安装目录：<code>/usr/local/nginx</code></p><p><code>cd /usr/local/nginx</code></p></li><li><p>进入sbin目录：<code>/sbin</code></p><p><code>cd /bin</code></p></li><li><p>启动</p><p><code>./nginx</code></p></li><li><p>浏览器访问</p><p>ip:8080</p></li></ul><p class="note note-danger">发现访问不到，因为防火墙阻止了访问，解决办法:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">1.直接关闭防火墙，一般生产和学习的时候可以直接关闭防火墙</span><br>systemctl stop firewalld.service<br>systemctl disable firewalld.service #禁止防火墙开机自启动<br><span class="hljs-meta prompt_">#</span><span class="language-bash">2.安全的方式：需要哪个端口才开放哪个</span><br>firewall-cmd --zone=public --add-port=80/tcp --permanent<br><span class="hljs-meta prompt_">#</span><span class="language-bash">重启防火墙</span><br>firewall-cmd --reload<br></code></pre></td></tr></table></figure><p class="note note-warning">五:关闭nginx及其他命令<p><ul><li>快速停止nginx <code>./nginx -s stop</code></li><li>优雅关闭，在退出前完成已经接收的请求 <code>./nginx -s quit</code></li><li>重新加载配置 <code>./nginx -s reload</code></li><li>查看nginx版本号 <code>./nginx -v</code></li></ul><p class="note note-warning">六:安装成系统服务<p><ul><li><p>创建服务脚本</p><p><code>vi /usr/lib/systemd/system/nginx.service</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell">[Unit]<br>Description=nginx - web server<br>After=network.target remote-fs.target nss-lookup.target<br><br>[Service]<br>Type=forking<br>PIDFile=/usr/local/nginx/logs/nginx.pid<br>ExecStartPre=/usr/local/nginx/sbin/nginx -t -c /usr/local/nginx/conf/nginx.conf<br>ExecStart=/usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf<br>ExecReload=/usr/local/nginx/sbin/nginx -s reload<br>ExecStop=/usr/local/nginx/sbin/nginx -s stop<br>ExecQuit=/usr/local/nginx/sbin/nginx -s quit<br>PrivateTmp=true<br><br>[Install]<br>WantedBy=multi-user.target<br></code></pre></td></tr></table></figure></li><li><p>重新加载系统服务</p><p><code>systemctl daemon-reload</code></p></li><li><p>启动服务</p><p><code>systemctl start nginx</code></p></li><li><p>关闭服务</p><p><code>systemctl stop nginx</code></p></li><li><p>重启服务</p><p><code>systemctl restart nginx</code></p></li><li><p>开启自启动</p><p><code>systemctl enable nginx</code></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>nginx</category>
      
    </categories>
    
    
    <tags>
      
      <tag>nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot中集成SpringSecurity和Jwt</title>
    <link href="/2023/09/30/SpringSecurity/"/>
    <url>/2023/09/30/SpringSecurity/</url>
    
    <content type="html"><![CDATA[<h3 id="如何在SpringBoot中集成SpringSecurity和Jwt？"><a href="#如何在SpringBoot中集成SpringSecurity和Jwt？" class="headerlink" title="如何在SpringBoot中集成SpringSecurity和Jwt？"></a>如何在SpringBoot中集成SpringSecurity和Jwt？</h3><blockquote><p>Jwt大家应该都比较熟悉，大家写安全框架应该用到最多的就是Jwt了，而SpringSecurity大多数是大项目在用然后最近浅学了一下SpringSecurity,但是网上的教程大多数的集成都是老版本，对于新版本的集成比较少，然后自己也是琢磨了很久，看了下官方文档，，然后现在浅浅记录一下集成过程吧。</p></blockquote><p class="note note-primary">前置用户类<p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@EqualsAndHashCode(callSuper = false)</span><br><span class="hljs-meta">@Accessors(chain = true)</span><br><span class="hljs-meta">@TableName(&quot;user_info&quot;)</span><br><span class="hljs-meta">@Alias(&quot;UserInfo&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserInfo</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<span class="hljs-comment">//序列化</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">1L</span>;<br>    <br>    <span class="hljs-meta">@TableId(value = &quot;id&quot;, type = IdType.AUTO)</span><br>    <span class="hljs-keyword">private</span> Integer id;<br>    <span class="hljs-keyword">private</span> String email;<span class="hljs-comment">//邮箱</span><br>    <span class="hljs-keyword">private</span> String password;<span class="hljs-comment">//密码</span><br>    <span class="hljs-keyword">private</span> String nickName;<span class="hljs-comment">//昵称</span><br>    <span class="hljs-keyword">private</span> String realName;<span class="hljs-comment">//真实姓名</span><br>    <span class="hljs-keyword">private</span> String phone;<span class="hljs-comment">//电话</span><br>    <span class="hljs-keyword">private</span> String sex;<span class="hljs-comment">//性别</span><br>    <span class="hljs-keyword">private</span> String avatar;<span class="hljs-comment">// 头像</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="一-引入依赖"><a href="#一-引入依赖" class="headerlink" title="一.引入依赖"></a><p class="note note-info">一.引入依赖<p></h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--SpringSecurity依赖--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--版本自选，或者父项目版本，本文用的3.1.3--&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--Jwt依赖--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.auth0<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>java-jwt<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.11.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="二-Jwt工具类"><a href="#二-Jwt工具类" class="headerlink" title="二.Jwt工具类"></a><p class="note note-info">二.Jwt工具类<p></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JwtUtils</span> &#123;<br>    <span class="hljs-comment">//算法密钥</span><br>    <span class="hljs-meta">@Value(&quot;$&#123;jwt.secretKey&#125;&quot;)</span><span class="hljs-comment">//在application.yml文件里写，然后注入</span><br>    <span class="hljs-keyword">private</span> String jwtSecretKey;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">createToken</span><span class="hljs-params">(String userInfo, List&lt;String&gt; authList)</span> &#123;<br>        <span class="hljs-comment">//创建时间</span><br>        <span class="hljs-type">Date</span> <span class="hljs-variable">currentTime</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br>        <span class="hljs-comment">//设置过期时间</span><br>        <span class="hljs-type">Date</span> <span class="hljs-variable">expireTime</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(currentTime.getTime() + (<span class="hljs-number">1000</span> * <span class="hljs-number">60</span> *  <span class="hljs-number">60</span> * <span class="hljs-number">24</span>));<br>        <span class="hljs-comment">//jwt 的header信息</span><br>        Map&lt;String, Object&gt; headerClaims = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        headerClaims.put(<span class="hljs-string">&quot;type&quot;</span>, <span class="hljs-string">&quot;JWT&quot;</span>);<br>        headerClaims.put(<span class="hljs-string">&quot;alg&quot;</span>, <span class="hljs-string">&quot;HS256&quot;</span>);<span class="hljs-comment">//加密算法</span><br>        <span class="hljs-comment">//创建jwt</span><br>        <span class="hljs-keyword">return</span> JWT.create()<br>                .withHeader(headerClaims) <span class="hljs-comment">// 头部</span><br>                .withIssuedAt(currentTime) <span class="hljs-comment">//已注册声明：签发日期，发行日期</span><br>                .withExpiresAt(expireTime) <span class="hljs-comment">//已注册声明 过期时间</span><br>                .withIssuer(<span class="hljs-string">&quot;xp&quot;</span>)  <span class="hljs-comment">//已注册声明，签发人</span><br>                .withClaim(<span class="hljs-string">&quot;userInfo&quot;</span>, userInfo) <span class="hljs-comment">//私有声明，可以自己定义</span><br>                .withClaim(<span class="hljs-string">&quot;auth&quot;</span>, authList) <span class="hljs-comment">//私有声明，可以自定义</span><br>                .sign(Algorithm.HMAC256(jwtSecretKey)); <span class="hljs-comment">// 签名，使用HS256算法签名，并使用密钥</span><br>        <span class="hljs-comment">//HS256是一种对称算法，这意味着只有一个密钥，在双方之间共享。 使用相同的密钥生成签名并对其进行验证。 应特别注意钥匙是否保密。</span><br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 验证jwt的签名，简称验签</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> token 需要验签的jwt</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 验签结果</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">verifyToken</span><span class="hljs-params">(String token)</span> &#123;<br>        <span class="hljs-comment">//获取验签类对象</span><br>        <span class="hljs-type">JWTVerifier</span> <span class="hljs-variable">jwtVerifier</span> <span class="hljs-operator">=</span> JWT.require(Algorithm.HMAC256(jwtSecretKey)).build();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//验签，如果不报错，则说明jwt是合法的，而且也没有过期</span><br>            <span class="hljs-type">DecodedJWT</span> <span class="hljs-variable">decodedJWT</span> <span class="hljs-operator">=</span> jwtVerifier.verify(token);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (JWTVerificationException e) &#123;<br>            <span class="hljs-comment">//如果报错说明jwt 为非法的，或者已过期（已过期也属于非法的）</span><br>            log.error(<span class="hljs-string">&quot;验签失败：&#123;&#125;&quot;</span>, token);<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//根据token获取用户信息</span><br>    <span class="hljs-keyword">public</span>  String <span class="hljs-title function_">getUserInfo</span><span class="hljs-params">(String token)</span>&#123;<br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-comment">// 使用秘钥创建一个解析对象</span><br>            JWTVerifier jwtVerifier=JWT.require(Algorithm.HMAC256(jwtSecretKey)).build();<br>            <span class="hljs-comment">//验证JWT</span><br>            <span class="hljs-type">DecodedJWT</span> <span class="hljs-variable">decodedJWT</span> <span class="hljs-operator">=</span> jwtVerifier.verify(token);<br>            <span class="hljs-type">Claim</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> decodedJWT.getClaim(<span class="hljs-string">&quot;userInfo&quot;</span>);<span class="hljs-comment">//注意对象要序列化</span><br>            <span class="hljs-keyword">return</span> username.asString();<br>        &#125;<span class="hljs-keyword">catch</span> (TokenExpiredException e)&#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>、<br>    <span class="hljs-comment">//通过token获取用户权限列表</span><br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">getAuth</span><span class="hljs-params">(String token)</span>&#123;<br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-comment">// 使用秘钥创建一个解析对象</span><br>            JWTVerifier jwtVerifier=JWT.require(Algorithm.HMAC256(jwtSecretKey)).build();<br>            <span class="hljs-comment">//验证JWT</span><br>            <span class="hljs-type">DecodedJWT</span> <span class="hljs-variable">decodedJWT</span> <span class="hljs-operator">=</span> jwtVerifier.verify(token);<br>            <span class="hljs-type">Claim</span> <span class="hljs-variable">auth</span> <span class="hljs-operator">=</span> decodedJWT.getClaim(<span class="hljs-string">&quot;auth&quot;</span>);<br>            <span class="hljs-keyword">return</span> auth.asList(String.class);<br>        &#125;<span class="hljs-keyword">catch</span> (TokenExpiredException e)&#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="三-新建安全用户类SecurityUser"><a href="#三-新建安全用户类SecurityUser" class="headerlink" title="三.新建安全用户类SecurityUser"></a><p class="note note-info">三.新建安全用户类SecurityUser<p></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SecurityUser</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserDetails</span> &#123;<span class="hljs-comment">//SpringSecurity提供的接口</span><br>    <span class="hljs-comment">//核心就是实现UserDeatils接口，登录的对象存在这个类里面</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> UserInfo userInfo;<br>    <br>    <span class="hljs-keyword">private</span> List&lt;SimpleGrantedAuthority&gt; simpleGrantedAuthorities;<br>    <br>    <span class="hljs-comment">//传入一个系统应用对象构造SecurityUser</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SecurityUser</span><span class="hljs-params">(UserInfo userInfo)</span> &#123;<br>        <span class="hljs-built_in">this</span>.userInfo = userInfo;<br>    &#125;<br><br><span class="hljs-comment">//如果设置了权限就在此实现给SecurityUser赋予权限业务</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Collection&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">GrantedAuthority</span>&gt; getAuthorities() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getPassword</span><span class="hljs-params">()</span> &#123;<br>        String userPassword=<span class="hljs-built_in">this</span>.userInfo.getPassword();<br>        <span class="hljs-comment">//注意清除密码，因为不想返回数据时让前端知道，只能由后端验证</span><br>        <span class="hljs-built_in">this</span>.userInfo.setPassword(<span class="hljs-literal">null</span>);<br>        <span class="hljs-keyword">return</span> userPassword;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getUsername</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.userInfo.getEmail();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isAccountNonExpired</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isAccountNonLocked</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isCredentialsNonExpired</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEnabled</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="四-将用户Service实现类实现UserDetailsService"><a href="#四-将用户Service实现类实现UserDetailsService" class="headerlink" title="四.将用户Service实现类实现UserDetailsService"></a><p class="note note-info">四.将用户Service实现类实现UserDetailsService<p></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserInfoServiceImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ServiceImpl</span>&lt;UserInfoMapper, UserInfo&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IUserInfoService</span>, UserDetailsService &#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> UserInfoMapper userInfoMapper;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> UserDetails <span class="hljs-title function_">loadUserByUsername</span><span class="hljs-params">(String email)</span> <span class="hljs-keyword">throws</span> UsernameNotFoundException&#123;<br>        <span class="hljs-type">UserInfo</span> <span class="hljs-variable">userInfo</span> <span class="hljs-operator">=</span> userInfoMapper.selectByEmail(email);<br>        <span class="hljs-keyword">if</span> (userInfo == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UsernameNotFoundException</span>(<span class="hljs-string">&quot;账号不存在&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SecurityUser</span>(userInfo);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="五-实现Jwt过滤器类，用于检查token"><a href="#五-实现Jwt过滤器类，用于检查token" class="headerlink" title="五.实现Jwt过滤器类，用于检查token"></a><p class="note note-info">五.实现Jwt过滤器类，用于检查token<p></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JwtCheckFilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">OncePerRequestFilter</span> &#123;<br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> ObjectMapper objectMapper;<br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> JwtUtils jwtUtils;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFilterInternal</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        <span class="hljs-comment">//获取请求uri</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">requestURI</span> <span class="hljs-operator">=</span> request.getRequestURI();<br>        <span class="hljs-comment">// 如果是登录页面，放行</span><br>        <span class="hljs-keyword">if</span> (requestURI.equals(<span class="hljs-string">&quot;/login&quot;</span>)) &#123;<br>            filterChain.doFilter(request, response);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">//获取请求头中的Authorization</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">authorization</span> <span class="hljs-operator">=</span> request.getHeader(<span class="hljs-string">&quot;Authorization&quot;</span>);<br>        <span class="hljs-comment">//如果Authorization为空，那么不允许用户访问，直接返回</span><br>        <span class="hljs-keyword">if</span> (!StringUtils.hasText(authorization)) &#123;<br>            printFront(response,<span class="hljs-string">&quot;未登录&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">//Authorization 去掉头部的Bearer 信息，获取token值</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">jwtToken</span> <span class="hljs-operator">=</span> authorization.replace(<span class="hljs-string">&quot;Bearer &quot;</span>, <span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-comment">//验签</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">verifyTokenResult</span> <span class="hljs-operator">=</span> jwtUtils.verifyToken(jwtToken);<br>        <span class="hljs-comment">//验签不成功</span><br>        <span class="hljs-keyword">if</span> (!verifyTokenResult) &#123;<br>            printFront(response,<span class="hljs-string">&quot;jwtToken 已过期&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">//从payload中获取userInfo</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">userInfo</span> <span class="hljs-operator">=</span> jwtUtils.getUserInfo(jwtToken);<br>        <span class="hljs-comment">//从payload中获取授权列表</span><br>        List&lt;String&gt; userAuth = jwtUtils.getAuth(jwtToken);<br>        <span class="hljs-comment">//创建登录用户</span><br>        <span class="hljs-type">UserInfo</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> objectMapper.readValue(userInfo, UserInfo.class);<br>        <span class="hljs-type">SecurityUser</span> <span class="hljs-variable">securityUser</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SecurityUser</span>(user);<br>        <span class="hljs-comment">//设置权限</span><br>        <span class="hljs-comment">//List&lt;SimpleGrantedAuthority&gt; authList = userAuth.stream().map(SimpleGrantedAuthority::new).collect(Collectors.toList());</span><br>        <span class="hljs-comment">//securityUser.setSimpleGrantedAuthorities(authList);</span><br>        <span class="hljs-type">UsernamePasswordAuthenticationToken</span> <span class="hljs-variable">usernamePasswordAuthenticationToke</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UsernamePasswordAuthenticationToken</span>(securityUser<br>                , <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);<br>        <span class="hljs-comment">//通过安全上下文设置认证信息</span><br>        SecurityContextHolder.getContext().setAuthentication(usernamePasswordAuthenticationToke);<br>        <span class="hljs-comment">//继续访问相应的url等</span><br>        filterChain.doFilter(request, response);<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printFront</span><span class="hljs-params">(HttpServletResponse response, String message)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        response.setCharacterEncoding(<span class="hljs-string">&quot;UTF-8&quot;</span>);<br>        response.setContentType(<span class="hljs-string">&quot;application/json;charset=utf-8&quot;</span>);<br>        <span class="hljs-type">PrintWriter</span> <span class="hljs-variable">writer</span> <span class="hljs-operator">=</span> response.getWriter();<br>        <span class="hljs-type">HttpResult</span> <span class="hljs-variable">httpResult</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpResult</span>();<br>        httpResult.setCode(<span class="hljs-number">500</span>);<br>        httpResult.setMessage(message);<br><br>        writer.print(objectMapper.writeValueAsString(httpResult));<br>        writer.flush();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="六-新建Security配置类"><a href="#六-新建Security配置类" class="headerlink" title="六.新建Security配置类"></a><p class="note note-info">六.新建Security配置类<p></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@EnableWebSecurity</span><br><span class="hljs-meta">@EnableMethodSecurity</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SecurityConfig</span> &#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> JwtUtils jwtUtils;<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> ObjectMapper objectMapper;<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> JwtCheckFilter jwtCheckFilter;<br>    <br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> SecurityFilterChain <span class="hljs-title function_">securityFilterChain</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        http.addFilterBefore(jwtCheckFilter, UsernamePasswordAuthenticationFilter.class);<br>        http.authorizeHttpRequests(auth -&gt; auth<br>                .anyRequest()<span class="hljs-comment">//所有请求</span><br>                .authenticated()<span class="hljs-comment">//都需要认证</span><br>        );<br>        http.formLogin(form -&gt; form<br>                .permitAll()<span class="hljs-comment">//登录接口放开</span><br>                .successHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">AuthenticationSuccessHandler</span>() &#123;<span class="hljs-comment">//认证成功处理器</span><br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onAuthenticationSuccess</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Authentication authentication)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>                        <span class="hljs-comment">//从认证信息中获取登录用户信息</span><br>                        <span class="hljs-type">SecurityUser</span> <span class="hljs-variable">securityUser</span> <span class="hljs-operator">=</span> (SecurityUser) authentication.getPrincipal();<br>                        <span class="hljs-type">UserInfo</span> <span class="hljs-variable">userInfo</span> <span class="hljs-operator">=</span> securityUser.getUserInfo();<br>                        <span class="hljs-type">String</span> <span class="hljs-variable">strUserInfo</span> <span class="hljs-operator">=</span> objectMapper.writeValueAsString(userInfo);<br><span class="hljs-comment">//                        List&lt;SimpleGrantedAuthority&gt; authorities = (List&lt;SimpleGrantedAuthority&gt;) securityUser.getAuthorities();</span><br><span class="hljs-comment">//                        List&lt;String&gt; authList = authorities.stream().map(SimpleGrantedAuthority::getAuthority).collect(Collectors.toList());</span><br><span class="hljs-comment">//                        //生成JWT</span><br>                        <span class="hljs-type">String</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> jwtUtils.createToken(strUserInfo, <span class="hljs-literal">null</span>);<br>                        <span class="hljs-type">HttpResult</span> <span class="hljs-variable">httpResult</span> <span class="hljs-operator">=</span> HttpResult.builder().code(<span class="hljs-number">200</span>).message(<span class="hljs-string">&quot;jwt生成成功&quot;</span>).data(<span class="hljs-string">&quot;Bearer &quot;</span>+token).build();<br>                        printToken(request,response,httpResult);<br>                    &#125;<br>                    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printToken</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response,HttpResult httpResult)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>                        <span class="hljs-type">String</span> <span class="hljs-variable">jwt</span> <span class="hljs-operator">=</span> objectMapper.writeValueAsString(httpResult);<br>                        response.setCharacterEncoding(<span class="hljs-string">&quot;UTF-8&quot;</span>);<br>                        response.setContentType(<span class="hljs-string">&quot;application/json;charset=utf-8&quot;</span>);<br>                        <span class="hljs-type">PrintWriter</span> <span class="hljs-variable">writer</span> <span class="hljs-operator">=</span> response.getWriter();<br>                        writer.println(jwt);<br>                        writer.flush();<br>                    &#125;<br>                &#125;)<br>        );<br>        http.csrf(csrf-&gt;csrf.disable());<br>        <span class="hljs-keyword">return</span> http.build();<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> PasswordEncoder <span class="hljs-title function_">passwordEncoder</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BCryptPasswordEncoder</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>到此为止，就可与使用啦😴😴😴😴</p>]]></content>
    
    
    <categories>
      
      <category>Web应用开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringBoot</tag>
      
      <tag>SpringSecurity</tag>
      
      <tag>Jwt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二分查找</title>
    <link href="/2023/09/29/BinarySearch/"/>
    <url>/2023/09/29/BinarySearch/</url>
    
    <content type="html"><![CDATA[<h2 id="二分查找的几种方式"><a href="#二分查找的几种方式" class="headerlink" title="二分查找的几种方式"></a>二分查找的几种方式</h2><p class="note note-success">第一种:左闭右闭</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>,j = nums.length-<span class="hljs-number">1</span>;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>       <span class="hljs-keyword">while</span>(i&lt;=j)&#123;<br>           m = (i+j)&gt;&gt;&gt;<span class="hljs-number">1</span>;<br>           <span class="hljs-keyword">if</span>(nums[m]&lt;target)&#123;<br>               i=m+<span class="hljs-number">1</span>;<br>           &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(target&lt;nums[m])&#123;<br>               j=m-<span class="hljs-number">1</span>;<br>           &#125;<span class="hljs-keyword">else</span>&#123;<br>               <span class="hljs-keyword">return</span> m;<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p class="note note-success">第二种：左闭右开</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>,j = nums.length;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>       <span class="hljs-keyword">while</span>(i&lt;j)&#123;<br>           m = (i+j)&gt;&gt;&gt;<span class="hljs-number">1</span>;<br>           <span class="hljs-keyword">if</span>(nums[m]&lt;target)&#123;<br>               i=m+<span class="hljs-number">1</span>;<br>           &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(target&lt;nums[m])&#123;<br>               j=m;<br>           &#125;<span class="hljs-keyword">else</span>&#123;<br>               <span class="hljs-keyword">return</span> m;<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p class="note note-success">第三种：平衡版二分查找</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>,j = nums.length;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>       <span class="hljs-keyword">while</span>(i &lt; j - <span class="hljs-number">1</span>)&#123;<br>           m = (i+j)&gt;&gt;&gt;<span class="hljs-number">1</span>;<br>           <span class="hljs-keyword">if</span>(target&lt;nums[m])&#123;<br>               j=m;<br>           &#125; <span class="hljs-keyword">else</span>&#123;<br>               i = m;<br>            &#125;<br>       &#125;<br>       <span class="hljs-keyword">return</span> (nums[i]==target)?i:-<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p class="note note-success">第四种：Arrays类的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>       <span class="hljs-keyword">return</span> Arrays.binarySearch(nums, target)&lt;<span class="hljs-number">0</span>?-<span class="hljs-number">1</span>:Arrays.binarySearch(nums, target);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统</title>
    <link href="/2023/09/27/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <url>/2023/09/27/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="操作系统导学案题目"><a href="#操作系统导学案题目" class="headerlink" title="操作系统导学案题目"></a>操作系统导学案题目</h1><p>[^written by 胥攀]: </p><h2 id="一-操作系统概念、功能、发展历史"><a href="#一-操作系统概念、功能、发展历史" class="headerlink" title="一.操作系统概念、功能、发展历史"></a>一.操作系统概念、功能、发展历史</h2><h3 id="1-为什么学习操作系统，其重要性，必要性，怎样学习操作系统？"><a href="#1-为什么学习操作系统，其重要性，必要性，怎样学习操作系统？" class="headerlink" title="1.为什么学习操作系统，其重要性，必要性，怎样学习操作系统？"></a>1.为什么学习操作系统，其重要性，必要性，怎样学习操作系统？</h3><p>答：学习操作系统是计算机科学和工程必不可少的一部分，学习操作系统有以下几个方面的重要性和必要性：</p><ol><li><p>提高计算机技能：操作系统是计算机系统的核心，所有应用软件都是建立在操作系统的基础上的，因此学习操作系统可以帮助我们更好地理解计算机系统的工作原理。</p></li><li><p>掌握计算机基础知识：操作系统涉及到计算机硬件、软件、网络等多方面的知识，学习操作系统可以帮助我们全面掌握计算机基础知识，有利于提高我们的学术水平和职业技能。</p></li><li><p>提高编程能力：操作系统是一个非常庞大和复杂的软件系统，学习操作系统可以帮助我们提高编程能力和软件工程技能，包括代码设计、调试和性能优化等方面的能力。</p></li><li><p>提高系统性能：对于系统管理员和网络管理员来说，学习操作系统可以帮助他们更好地管理和维护计算机系统，提高系统的稳定性和性能，降低维护成本。</p></li></ol><p>学习操作系统的方法有很多种，包括自学、参加课程、阅读相关书籍、参与开源项目等等。如果想要深入学习操作系统，建议从计算机原理和操作系统基础开始学习，了解计算机的体系结构、CPU指令集、CPU中断处理、内存管理、文件系统等基本概念和原理，然后可以阅读《操作系统概念》、《现代操作系统》等操作系统经典教材，跟随开源社区的项目实践来深入探究操作系统的内部机制和实现原理。</p><h3 id="2-有人认为windows，Mac-OS，Android就够用了，不必再开发操作系统；有人说所谓的国产系统就是Linux包装一下，毫无意义；有人认为研究院、高校都应该投入人员经费去做操作系统的研究。你如何评价这些观点"><a href="#2-有人认为windows，Mac-OS，Android就够用了，不必再开发操作系统；有人说所谓的国产系统就是Linux包装一下，毫无意义；有人认为研究院、高校都应该投入人员经费去做操作系统的研究。你如何评价这些观点" class="headerlink" title="2.有人认为windows，Mac OS，Android就够用了，不必再开发操作系统；有人说所谓的国产系统就是Linux包装一下，毫无意义；有人认为研究院、高校都应该投入人员经费去做操作系统的研究。你如何评价这些观点."></a>2.有人认为windows，Mac OS，Android就够用了，不必再开发操作系统；有人说所谓的国产系统就是Linux包装一下，毫无意义；有人认为研究院、高校都应该投入人员经费去做操作系统的研究。你如何评价这些观点.</h3><p>答：这些观点都有一定道理，但需要从多个角度来评价。我的观点如下：</p><ol><li><p>Windows、MAC OS和Android等操作系统已经足够丰富，而且已经在不同领域得到了广泛应用，因此某种程度上确实没有必要再开发新的操作系统。但是，从科技创新和技术进步的角度来看，操作系统的研究和开发仍然具有巨大价值。新的操作系统可能引入新的编程模型、新的应用场景和新的技术特性，从而带来更多的变革和突破。</p></li><li><p>国产操作系统虽然通常基于开源Linux系统构建，但这并不代表它们毫无意义。国产系统在不断创新和改进，以适应国内的不同需求和市场环境。此外，国产系统还具有信息安全和自主可控的优势，可以提高国内计算机系统的安全性和稳定性。因此，国产操作系统在中国的发展仍然具有重要的意义。</p></li><li><p>对于研究院和高校而言，从事操作系统的研究和开发是重要的学术课题和技术挑战。操作系统不仅是计算机领域的基础和核心，而且也涉及到人工智能、物联网、边缘计算等重要的技术领域。因此，投入人员和经费进行操作系统研究和开发也是非常有意义和必要的。</p></li></ol><p>总之，操作系统的研究和开发对于计算机领域和产业的发展都具有重要的贡献，我们应该鼓励和支持这方面的探索和创新。</p><h3 id="3-一些教材指出操作系统的4个特征：并发、共享、虚拟、异步，教材17页的“不确定性”对应着什么？请对这些特征做出解释。"><a href="#3-一些教材指出操作系统的4个特征：并发、共享、虚拟、异步，教材17页的“不确定性”对应着什么？请对这些特征做出解释。" class="headerlink" title="3.一些教材指出操作系统的4个特征：并发、共享、虚拟、异步，教材17页的“不确定性”对应着什么？请对这些特征做出解释。"></a>3.一些教材指出操作系统的4个特征：并发、共享、虚拟、异步，教材17页的“不确定性”对应着什么？请对这些特征做出解释。</h3><p>答：教材的“不确定性”特征可以理解为“并发”和“异步”特征的结合。操作系统中的不确定性主要是指在多个进程同时执行的情况下，处理器和IO设备的请求会以不可预测的顺序出现，而且操作系统无法预测它们的调度顺序。这种不确定性也被称为“竞态条件”（race condition），可能会导致进程出现不可预测的结果。</p><p>四个特征的解释如下：</p><ol><li><p>并发（Concurrency）：指在一个时间段内，有多个程序同时运行。在单处理器系统中，并发是通过中断、时钟中断或多道程序设计技术来实现的。而在多处理器系统中，则存在真正的并行处理。</p></li><li><p>共享（Sharing）：指系统中的资源（如硬盘、打印机等）可供多个进程或用户共同使用。因为资源有限，它的访问需要协调和管理。</p></li><li><p>虚拟（Virtualization）：指通过一种方式，把一个物理资源转化为多个逻辑上的资源，使得多个进程或用户可以同时使用这些资源。例如，虚拟地址空间允许多个进程共享内存，但每个进程都认为内存是独占的。</p></li><li><p>异步（Asynchrony）：指操作系统无法预测进程的请求和执行时间，请求和执行之间的时间间隔可能不确定。这是因为进程的请求时间和执行时间都受到许多因素的影响，如用户输入、IO操作等。为了应对这种不确定性，操作系统通常采用中断处理、调度算法等方式。</p><p>总之，这四个特征是操作系统的核心功能，这四个特征的组合为计算机系统提供了基础设施，使多个进程或用户可以共享资源并在同一时间运行。同时，由于操作系统的特殊性质，操作系统的分析、设计和实现都与它们有着密切的联系。</p></li></ol><h3 id="4-并行和并发的区别与联系？现代计算机内有多少CPU？程序运行是并行还是并发？"><a href="#4-并行和并发的区别与联系？现代计算机内有多少CPU？程序运行是并行还是并发？" class="headerlink" title="4.并行和并发的区别与联系？现代计算机内有多少CPU？程序运行是并行还是并发？"></a>4.并行和并发的区别与联系？现代计算机内有多少CPU？程序运行是并行还是并发？</h3><p>答：并行（Parallel）和并发（Concurrency）是两个概念。</p><p>并发是指多个任务在同一时间段内被执行，常常是在一个 CPU 上轮流交替执行多个任务，从而造成多个任务同时执行的错觉。</p><p>并行是指多个任务在同一时间点上被执行，多个 CPU 可以同时处理多个任务，也就是说，可以同时执行多个计算环节。</p><p>现代计算机内部的 CPU 数量很大程度上取决于计算机设备的计算能力需求，从日常使用的 PC 和 Mac 等台式机和笔记本电脑中的 2 或 4 核 CPU，到数据中心和高性能计算机（HPC）中可拓展到超过数千个核心的 CPU。</p><p>程序运行时并行还是并发，则取决于实际使用的计算环境。在单个 CPU 计算机上运行的程序通常是并发的，而在拥有多个 CPU 的计算机设备上运行的程序可能同时执行并行计算。</p><h3 id="5-有人说：专心做事一件事比同时做多件事效率高，那么多道系统效率没有单道系统效率高，这种说法是否正确？单道的好处是什么，多道系统是否已经取代了单道系统？"><a href="#5-有人说：专心做事一件事比同时做多件事效率高，那么多道系统效率没有单道系统效率高，这种说法是否正确？单道的好处是什么，多道系统是否已经取代了单道系统？" class="headerlink" title="5.有人说：专心做事一件事比同时做多件事效率高，那么多道系统效率没有单道系统效率高，这种说法是否正确？单道的好处是什么，多道系统是否已经取代了单道系统？"></a>5.有人说：专心做事一件事比同时做多件事效率高，那么多道系统效率没有单道系统效率高，这种说法是否正确？单道的好处是什么，多道系统是否已经取代了单道系统？</h3><p>答：这种说法是有道理的。专心做一件事比同时做多件事更能提高效率，因为当我们专注于一件事情时，可以更好地集中精力和资源，能够更快地完成任务，减少遗漏和错误的概率。同时，多任务切换所带来的上下文切换开销也会降低计算机系统的整体效率。</p><p>单道系统是指一次只能处理一个任务或进程的操作系统，在单任务条件下，一旦任务进入就会一直执行，直到其运行结束为止。单道系统的好处是简单，易于实现和维护，而且可以避免多任务切换的开销和调度问题。它适用于资源简单的环境，在较简单的场景下可以优化整个系统。</p><p>然而，现代计算机系统中多数采用多道系统（Multi-Programming System)。多道系统意味着多个进程同时在计算机系统中工作，计算机系统可以在每个程序的执行过程中完成多任务切换，充分利用 CPU 和其他资源，从而提高整个系统的效率。</p><p>相较于单道系统，多道系统最大的好处在于可以有效地充分利用资源，减少了进程等待时间，同时提高了系统的响应速度。此外，多道系统可以兼容多种应用程序，提升整个系统的兼容性和应用场景。</p><p>总之，单道系统的好处在于简单和易于实现维护，但是在现代计算机系统中，多道系统已经成为主流，它充分利用了计算机资源，并且可以为多个进程和应用程序提供更好的服务和支持。<br>关于“专心做事一件事比同时做多件事效率高，那么多道系统效率没有单道系统效率高，这种说法是否正确？”的问题，需要根据具体情况进行分析。从原则上来说，多道系统的效率应该比单道系统的效率高，这是因为多道系统允许系统同时处理多个任务，进而提高了 CPU、内存等系统资源的利用率，从而达到更高的系统吞吐量和更少的等待时间。但是，由于多道系统需要对多个任务之间的资源共享和调度进行管理，因此需要更大的系统内核和管理开销，也有可能带来更多的垂直性能下降。因此，在实践中，选择单道系统还是多道系统应该根据具体的应用场景和性能指标进行比较和选择。</p><p>单道系统的优势在于在运行单个进程时拥有最高的系统资源利用率，以及更少的资源调度和管理开销。因此，在需要处理具有一致性需求的独立任务（例如单个应用程序、服务等）时，单道系统可能是一个良好的选择。相反，多道系统更适用于需要同时处理多个任务且需要较高资源的场景。</p><p>随着计算机系统的发展，多道系统已经基本上取代了单道系统，因为多道系统在大多数应用场景下具有更高的效率和性能。但是，一些特定的应用场景，例如实时系统和嵌入式系统，在实践中需要使用单道系统或者单道处理器。</p><h3 id="6-实时系统的概念、衡量指标等，Windows响应速度很快，是否是实时系统？"><a href="#6-实时系统的概念、衡量指标等，Windows响应速度很快，是否是实时系统？" class="headerlink" title="6.实时系统的概念、衡量指标等，Windows响应速度很快，是否是实时系统？"></a>6.实时系统的概念、衡量指标等，Windows响应速度很快，是否是实时系统？</h3><p>答：实时系统是指计算机或嵌入式系统需要在严格的时间限制内完成任务。实时系统可以分为硬实时系统和软实时系统。硬实时系统需要以确切的时序满足主要任务，而软实时系统可以容忍一定程度的偏差。实时系统的性能通常由以下几个指标进行衡量：</p><ol><li><p>响应时间：指从发出请求到获得回应的时间，即从请求到任务完成所需的时间。</p></li><li><p>周转时间：指从任务发起到任务结束的时间。</p></li><li><p>时序准确度：系统是否能够在精确的时间内完成任务。</p></li><li><p>中断延迟：指硬实时系统在收到中断请求后，能够在完全准确的时间内完成任务的能力。</p></li></ol><p>Windows 不是一个实时系统。虽然 Windows 响应速度很快，但它并没有设计成一个硬实时系统。这是因为 Windows 为了提供更好的用户体验和计算能力，会在不同的时间段执行不同的任务，并且在网络和 IO 调度上具有不完全可预测的性质。然而，对于许多正常用户的应用，如文档编辑、图片处理和多媒体播放等方面，Windows 具有很高的实时性和实用性，可以完全满足常见任务的需求。</p><h3 id="7-多核和多CPU-的解释，和并行并发的关系"><a href="#7-多核和多CPU-的解释，和并行并发的关系" class="headerlink" title="7.多核和多CPU 的解释，和并行并发的关系"></a>7.多核和多CPU 的解释，和并行并发的关系</h3><p>答：多核和多CPU是指现代计算机系统中的两种不同的多处理器技术。</p><p>多核处理器可以在一个 CPU 芯片内集成多个独立的处理核心，每个核心可以独立处理多个任务或线程，并共享 CPU 内部缓存和其他系统资源。多核处理器提高了计算机系统的运行速度和处理能力，节省了能源和物理空间成本，并降低了计算机系统的复杂性和故障率。</p><p>另一方面，多个 CPU 并行工作，每个 CPU 都可以执行不同的任务或处理线程。与多核处理器相比，多 CPU 处理器需要更多的物理空间、系统资源和能量，并且需要更多的硬件、系统软件和操作系统支持。多 CPU 处理器可以在应用程序中实现更高的并行性，以提高应用程序的性能。</p><p>并行和并发是两个有密切关系但却不同的概念。</p><p>并行可以理解为多个任务在同一时间点上被运行。也就是说，多个任务同时发生，并且不互相干扰。在计算机领域，多个 CPU 可以同时处理多个任务，即并行计算。</p><p>并发是指多个任务在同一时间段内被运行，并且它们会相互干扰和影响。在单 CPU 系统中，由于操作系统调度算法的存在，一个进程在处理 I&#x2F;O 操作的同时，可能会暂停它的 CPU 请求，允许其他进程获得 CPU 执行时间。通过这种方式，多个进程可以同时运行，但是它们共享 CPU 和其他系统资源，产生资源争用问题。</p><p>总之，并行指的是同一时间点上多个任务的处理能力，而并发指的是同一时间段内多个任务的处理能力。多核和多 CPU 处理器都可以实现更高的并行性和并发性，提高计算机系统的性能和效率。</p><h3 id="8-Linux是开源软件，自由-Free-软件，开源协议GPL是什么意思，开源和免费的关系"><a href="#8-Linux是开源软件，自由-Free-软件，开源协议GPL是什么意思，开源和免费的关系" class="headerlink" title="8.Linux是开源软件，自由(Free)软件，开源协议GPL是什么意思，开源和免费的关系"></a>8.Linux是开源软件，自由(Free)软件，开源协议GPL是什么意思，开源和免费的关系</h3><p>答：GNU General Public License (GPL) 是一种开源软件使用和分发的许可协议。GPL 允许开发者免费地使用、复制、修改、发布软件，并强制其在分发时开放源代码，并使用 GPL 许可协议分发其衍生作品。使用 GPL 许可协议发布的软件可以自由使用，分发，修改，同时分发的任何衍生作品也必须在同一许可协议下分发，并且需要开放源代码。</p><p>开源软件指的是可以通过查看源代码来了解应用程序运行的细节、机制和结构，且可以免费使用和分发的软件。开源不一定免费，但是开源软件通常是免费的或者使用费用相对较低。开源软件的使用者可以修改源代码以适应自己的需求和用途，但是需要遵守适用的版权和许可协议。</p><p>自由软件指的是可以自由地使用、复制、分发，同时也可以查看和修改源代码的软件。自由软件的使用者可以自由地改进、扩展、修改代码以适应自己的需要，而不需要担心任何版权问题。开源软件和自由软件基本上是相同的，只是侧重点不同，自由软件更注重于更广泛的自由和隐私权，开源软件更注重于源代码的公开性和透明度。</p><p>开源和免费的概念密切相关，但是并不等价。开源软件的源代码是公开可见的，因此用户可以阅读和了解应用程序的实现细节和机制，同时也可以自由地修改代码和创造衍生作品。然而，开源并不一定代表免费，一些开源软件可能会收取使用费用，例如 Red Hat 的商业 Linux 发行版。而免费软件并不一定是开源的，例如某些专有软件可能是免费的，但是源代码是不公开的。</p><p>综上所述，开源和免费是相关但不等价的概念，GPL 协议是一种保护开源软件的许可证，允许软件使用者在符合一定条件的情况下免费地制作、发布和修改软件的源代码，同时确保它们的修改必须是开放源代码的。</p><h3 id="9-查阅资料了解和操作系统相关的几个著名人物：理查德斯托曼，肯·汤普森等的事迹"><a href="#9-查阅资料了解和操作系统相关的几个著名人物：理查德斯托曼，肯·汤普森等的事迹" class="headerlink" title="9.查阅资料了解和操作系统相关的几个著名人物：理查德斯托曼，肯·汤普森等的事迹"></a>9.查阅资料了解和操作系统相关的几个著名人物：理查德斯托曼，肯·汤普森等的事迹</h3><p>答：</p><ol><li>Richard Stallman (理查德·马修·斯托曼)</li></ol><p>Richard Stallman，简称 rms，是计算机自由软件运动的奠基人之一，他于1983年创立了自由软件基金会（Free Software Foundation，以下简称 FSF），并发起了 GNU 项目。他是 GNU 通用公共许可证（General Public License，以下简称 GPL）的主要设计者之一，这也是开源软件中最有影响力的许可证之一。</p><p>理查德·斯托曼始终奉行自由软件的理念，坚信开源软件的必要性，并在许多场合发表演讲和文章，阐述自由软件运动的哲学和理念。他一直倡导将软件视为基本权利而非商品，其目标是为了推动自由软件的发展、提高人民自治权利、抵制商业对数字科技的控制、促进信息交流和知识共享等。</p><ol start="2"><li>Ken Thompson（肯·汤普森）</li></ol><p>肯·汤普森（Kenneth Lane Thompson）是贝尔实验室早期的研究员，是 Unix 操作系统的联合创始人之一。他和丹尼斯·里奇一起，发明了 C 语言并使用 C 语言重新实现了 Unix 操作系统，从而为操作系统的可移植性和跨平台性打下了坚实的基础。</p><p>肯·汤普森还开发了正则表达式、stream编辑器（sed）、文本编辑器（QED、ed、vi）、图形绘制语言（Pic）、类型排版语言（troff）等基础工具。他被授予图灵奖等多项荣誉，以表彰其对计算机科学的贡献。</p><ol start="3"><li>Linus Torvalds（林纳斯·托瓦兹）</li></ol><p>林纳斯·托瓦兹（Linus Torvalds）是著名的计算机科学家和程序员，他创立了 Linux 操作系统和 Git 版本控制软件。在大学时，他模仿 Unix 操作系统，于1991年创建了 Linux 内核，开启了开源软件的新时代。</p><p>Linux 操作系统代表了开源软件的历史和现在，它发展迅速，已经成为科学计算、企业服务器、嵌入式系统和智能手机等领域的主流操作系统。林纳斯·托瓦兹是 Linux 的创建者和维护者，他致力于开启计算机软件的开源文化，同时也是开源共享精神的代表人物之一。</p><p>总之，这些人物对计算机行业都做出了重要的贡献，他们的事迹和思想对计算机领域的发展和推动给予了重要影响。在计算机技术的不断发展中，他们的事迹也会为人们提供重要的借鉴和参考。</p><h3 id="10-批处理系统中有个概念：吞吐量，了解吞吐量的含义"><a href="#10-批处理系统中有个概念：吞吐量，了解吞吐量的含义" class="headerlink" title="10.批处理系统中有个概念：吞吐量，了解吞吐量的含义"></a>10.批处理系统中有个概念：吞吐量，了解吞吐量的含义</h3><p>   答：在计算机科学中，吞吐量（throughput）是衡量在一定时间内一台机器处理的工作量的指标，通常用于评估计算机系统的性能。吞吐量可以用于衡量并发系统的能力，比如 web 服务器、数据库服务器等，这些系统需要同时处理多个请求，因此需要具备较高的吞吐量来支持高并发。</p><p>   吞吐量通常被定义为在一个指定时间段内，计算机系统处理任务的数量。例如，一个网络服务器每秒钟处理 100 个请求，则其吞吐量为 100 请求&#x2F;秒。吞吐量通常与响应时间（response time）一同使用来衡量计算机系统的效率和性能。响应时间是指完成单个任务所需的时间，而吞吐量则是单个系统在某个时间段内完成任务的数量。</p><p>   在批处理系统中，吞吐量是指在一定时间内完成的任务数量。批处理系统通常被用于处理大量相似或重复的任务，它们的工作流程是自动化的，完全依赖于系统内部预定义的规则和流程。批处理系统需要快速处理大量的数据并生成处理结果，因此需要具备较高的吞吐量来支持。</p><p>   吞吐量通常是计算机系统性能评估中的一个关键指标，它受到多个因素的影响，包括硬件设备、操作系统、应用程序等。在优化计算机系统性能时，可以通过增加系统硬件容量、优化算法、调整应用程序代码等方式来提高吞吐量，从而提高系统的总体性能。</p><h3 id="11-脱机批处理系统的工作过程"><a href="#11-脱机批处理系统的工作过程" class="headerlink" title="11.脱机批处理系统的工作过程"></a>11.脱机批处理系统的工作过程</h3><p>答：脱机批处理系统是一种计算机系统，它的主要作用是自动完成大量重复性的任务，例如数据处理、报表生成等等。脱机批处理系统有自己独立的程序和数据存储空间，并在不需要用户交互或控制的情况下，按照预先定义的任务列表自动执行任务。下面是脱机批处理系统的工作过程：</p><ol><li><p>操作员编写作业卡（job card）：在脱机批处理系统中，操作员首先需要编写一个包含程序和处理参数等信息的作业卡。作业卡通常包含作业名称、输入文件和输出文件名、程序名称、处理参数等等信息。</p></li><li><p>提交作业卡：操作员将作业卡提交给脱机批处理系统管理人员，经过一定的审核和检查后，将该作业加入到作业队列中。</p></li><li><p>作业调度：脱机批处理系统管理程序根据一定的作业优先级、资源使用、作业依赖等考虑因素，对作业队列中的作业进行调度。当系统准备好处理某个作业时，便要求操作员将相关的数据文件加载到系统中。</p></li><li><p>作业运行：当作业进入系统后，脱机批处理系统按照指定的程序处理数据文件，执行各种计算任务，处理流程完全自动进行。作业运行期间系统会记录各种运行日志，如错误信息、处理时间、处理的输入及输出等等。</p></li><li><p>输出数据和作业控制：当作业运行完毕后，系统会将处理的结果存储在输出数据文件中。在输出数据完毕后，脱机批处理系统会将运行日志和输出数据文件等信息交还给管理人员，以供后续的操作和使用。</p></li></ol><p>脱机批处理系统的工作过程是操作员提交作业卡，由系统自动运行、处理输出数据，整个过程是离线的、自动化的，这种方式可以大量节约人力、时间和成本，非常适用于处理大量相似工作的场景，例如日报、批量数据处理等场景。</p><h3 id="12-描述计算机的启动过程"><a href="#12-描述计算机的启动过程" class="headerlink" title="12.描述计算机的启动过程"></a>12.描述计算机的启动过程</h3><p>答：计算机的启动过程又称为引导（boot），是指将计算机从关机状态转化为运行状态所必须的过程。计算机启动过程是一个复杂的过程，一般分为硬件自检（POST）、主引导记录（MBR）载入、操作系统内核载入、系统初始化、系统自举等多个步骤，以下是计算机的基本启动过程：</p><ol><li><p>电源供电：计算机的启动首先需要电源供电，用户通过按下电源按钮使电源启动并进入待机状态。</p></li><li><p>硬件自检（POST）：计算机启动后，CPU 首先执行自检程序（POST），对计算机内部硬件设备进行诊断和测试，确认所有硬件设备都正常工作，以确保计算机能够正常启动。</p></li><li><p>主引导记录加载（MBR）：硬件自检结束后，计算机开始读取主引导记录（MBR），并加载启动管理程序（boot loader），该程序具有启动操作系统的指令。</p></li><li><p>操作系统内核载入：启动管理程序开始执行，加载操作系统的内核文件（kernel）。这个过程涉及到主板芯片组（chip set），用于与其它系统组件通信的设配器（例如磁盘控制器），以及操作系统驱动程序的加载。</p></li><li><p>系统初始化：一旦操作系统内核加载完成，它就开始初始化系统并将控制权交给操作系统。初始化过程涉及各种设备驱动程序、网络协议和文件系统等方面。</p></li><li><p>用户登录：操作系统启动后，会启动登录界面，用户需要输入用户名和密码以登录系统，然后可开始进行各种操作。</p></li></ol><p>总之，计算机启动过程是一个由硬件自检、主引导记录加载、操作系统内核载入、系统初始化、用户登录等多个步骤组成的序列，需要参与多个组件的密切协作，从而使计算机从关机状态转化为运行状态，并准备就绪等待用户进行各种操作。</p><hr><h2 id="二-操作系统逻辑结构和硬件知识"><a href="#二-操作系统逻辑结构和硬件知识" class="headerlink" title="二.操作系统逻辑结构和硬件知识"></a>二.操作系统逻辑结构和硬件知识</h2><h3 id="1-操作系统几种模式的特点（优缺点），给出一些考题"><a href="#1-操作系统几种模式的特点（优缺点），给出一些考题" class="headerlink" title="1.操作系统几种模式的特点（优缺点），给出一些考题"></a>1.操作系统几种模式的特点（优缺点），给出一些考题</h3><p>答：操作系统常见的模式有用户模式和内核模式，下面分别介绍其特点和考题：</p><ol><li>用户模式</li></ol><p>用户模式是指操作系统允许用户直接访问硬件资源、运行自己的应用程序、进行各种操作的一种模式。用户模式下，应用程序没有权限直接操作硬件资源，而是通过系统调用（system call）向操作系统申请执行某些操作，操作系统会切换到内核模式，执行相应的操作，并返回结果给应用程序。</p><p>优点：<br>- 支持多任务，多用户的并发执行<br>- 运行速度快，适合于用户应用程序</p><p>缺点：<br>- 缺乏对硬件资源的直接访问权限<br>- 无法直接访问内核数据结构，对系统调用的过度使用会影响系统性能</p><p>考题：<br>- 请简述用户模式的特点和优缺点。<br>- 给出一种常见的操作系统API（Application Programming Interface），说明该API和用户模式的关系。<br>- 操作系统如何保证用户模式下应用程序的安全性？</p><ol start="2"><li>内核模式</li></ol><p>内核模式是指操作系统拥有对所有硬件资源的直接、完全控制权，并能执行所有指令的一种模式。在内核模式下，操作系统能够直接操作硬件资源、执行各种内核功能。当应用程序进行系统调用时，操作系统会检查请求的合法性，然后进入内核模式执行相应的操作。</p><p>优点：<br>- 对硬件资源有直接的访问权限<br>- 可以访问内核数据结构，支持更高级别的系统调用</p><p>缺点：<br>- 在内核模式下，操作系统运行速度比用户模式慢<br>- 内核模式下的代码容易受到恶意攻击</p><p>考题：<br>- 请简述内核模式的特点和优缺点。<br>- 在操作系统中，什么情况下会触发用户模式和内核模式之间的切换？<br>- 请简要说明内核模式和用户模式之间的区别。</p><p>除此之外，还有一些特殊模式，例如实时模式、虚拟模式等，都有各自的优缺点和适用条件。</p><h3 id="2-用自己的语言描述一下内核到底是什么，如何理解用户模式-用户态-，内核模式-内核态-，内核和内核态，用户程序和用户态有什么区别和联系？"><a href="#2-用自己的语言描述一下内核到底是什么，如何理解用户模式-用户态-，内核模式-内核态-，内核和内核态，用户程序和用户态有什么区别和联系？" class="headerlink" title="2.用自己的语言描述一下内核到底是什么，如何理解用户模式(用户态)，内核模式(内核态)，内核和内核态，用户程序和用户态有什么区别和联系？"></a>2.用自己的语言描述一下内核到底是什么，如何理解用户模式(用户态)，内核模式(内核态)，内核和内核态，用户程序和用户态有什么区别和联系？</h3><p>答：操作系统的内核（kernel）是操作系统的核心部分，它负责管理系统的各种资源和功能，如进程管理、内存管理、文件系统、设备管理等。内核掌握系统对硬件的访问权限，提供应用程序访问系统资源的接口，同时保证系统的可靠稳定运行。</p><p>用户模式和内核模式是CPU的执行状态，也称为用户态和内核态。在用户模式下，应用程序只能访问自己的地址空间和系统调用接口，不能直接操作硬件资源。在内核模式下，操作系统拥有对所有硬件资源的直接控制权，可以执行任何运算和操作，但应用程序无法直接访问内核代码。</p><p>用户程序和用户态指的是一种运行状态，即应用程序的运行环境。在用户态下，应用程序只能访问自己的地址空间和系统调用接口，无权直接操作硬件资源。在内核态下，操作系统掌握对所有硬件资源的直接访问权限，应用程序无法直接访问内核代码。</p><p>内核，指的是操作系统的核心部分，即计算机操作系统中控制计算机硬件和软件资源的核心程序。操作系统的内核提供一系列系统调用API（Application Programming Interface），允许应用程序使用操作系统的服务和资源。</p><p>用户程序和内核程序之间的区别和联系：用户程序只能在用户态中运行，不能直接访问内核的资源，必须通过系统调用来请求内核来完成特定的操作。内核程序在内核态中运行，能够访问所有系统资源。应用程序可以通过系统调用访问内核中的程序代码，而系统调用则是一个中断机制，使得操作系统能够从用户态切换到内核态，完成所需的操作，然后再返回到用户态。</p><h3 id="3-解释“系统调用”，说明为什么要有系统调用，如何调用"><a href="#3-解释“系统调用”，说明为什么要有系统调用，如何调用" class="headerlink" title="3.解释“系统调用”，说明为什么要有系统调用，如何调用"></a>3.解释“系统调用”，说明为什么要有系统调用，如何调用</h3><p>答：系统调用是操作系统提供的一组API（应用程序接口），它是让应用程序可以访问操作系统内核的服务和资源的一种方式。操作系统内核负责管理系统的各种资源和功能，如进程管理、内存管理、文件系统、设备管理等，而应用程序需要这些服务和资源才能完成自己的任务。</p><p>为什么要有系统调用呢？这是因为操作系统内核一般运行在特权模式下，可以访问系统硬件资源，而用户程序一般运行在非特权模式下，不能直接访问硬件资源，必须通过操作系统内核提供的API接口来实现对系统资源的访问和操作。为了保证操作系统的安全和稳定，系统调用提供了一种安全而可控制的方式，让应用程序可以访问系统资源，同时又不会中断操作系统的正常运行。</p><p>操作系统提供的系统调用包括读写文件、创建和销毁进程、设置定时器、网络通信等功能。调用系统调用时，应用程序需要使用系统调用号码来唤醒操作系统内核，让内核来执行相应的任务。</p><p>在各个操作系统中，系统调用的具体实现方法有所不同。以Linux为例，常用的系统调用有open、read、write、close等，这些系统调用实际是通过中断机制来调用。当应用程序执行系统调用时，会通过软件中断INT 80H的方式进入内核态，从而向操作系统申请相应的服务。操作系统内核处理完请求后，再返回应用程序，并把请求结果传递给应用程序。</p><p>需要注意的是，使用系统调用时要小心不要滥用，因为操作系统的内核是一个运行在特权模式下的核心程序，访问它的代价比较高昂。如果应用程序过于频繁地使用系统调用，可能会导致不必要的上下文切换和资源浪费，从而影响系统性能。</p><h3 id="4-解释“中断机制”：为什么要使用中断？中断什么时候发生？发生的原因？中断发生后是什么样？"><a href="#4-解释“中断机制”：为什么要使用中断？中断什么时候发生？发生的原因？中断发生后是什么样？" class="headerlink" title="4.解释“中断机制”：为什么要使用中断？中断什么时候发生？发生的原因？中断发生后是什么样？"></a>4.解释“中断机制”：为什么要使用中断？中断什么时候发生？发生的原因？中断发生后是什么样？</h3><p>答：中断机制是操作系统的核心机制之一，它是实现操作系统与外部设备交互的重要方式。中断是指外部设备向CPU发出的一种信号，通知其需要进行响应处理。在计算机中，中断可以分为硬件中断和软件中断两种类型。</p><p>为什么要使用中断？中断机制是一种异步机制，可以让CPU在正常运行代码的同时，对外部事件做出及时的响应。使用中断可以提高设备的利用率，降低CPU的负载，使计算机系统能够更加高效地运行。</p><p>中断什么时候发生？发生的原因？中断一般由硬件设备发出，通知CPU需要执行相应的服务程序。比如当一个按键按下时，会产生一个中断信号，通知CPU需要执行键盘中断处理程序来响应该事件。</p><p>中断发生后，CPU会把当前的执行状态保存（即保存相关的寄存器内容和下一条指令的地址等信息），并切换到中断处理程序进行处理。处理程序往往是由操作系统提供的，用于执行设备驱动程序、处理设备数据、更新内核数据结构等任务。在处理程序执行完成后，CPU会恢复中断之前的执行状态，继续执行被中断的程序。</p><p>需要注意的是，中断机制是操作系统对外部事件的响应方式，必须对中断进行适当的管理和调度，避免因过多的中断请求导致系统资源的浪费和不必要的上下文切换。为了实现合理的中断管理，操作系统会针对不同的中断源，设置不同的优先级和响应策略，以保证系统的稳定运行。</p><h3 id="5-讲解“总线”"><a href="#5-讲解“总线”" class="headerlink" title="5.讲解“总线”"></a>5.讲解“总线”</h3><p>答：总线（Bus）是一种用于在计算机内部各个组件之间传输数据的通信线路。它是计算机体系结构中的基础，用于将各种设备、组件和子系统连接起来，实现它们之间的可靠通信和协同工作。</p><p>总线通常分为地址总线、数据总线和控制总线三部分。其中，地址总线用于传输设备或者存储器的地址信息，控制总线用于传输控制信号，例如读写控制信号、中断请求信号等。而数据总线则用于传输数据和指令信息，从而实现对内存、外设的读写等操作。</p><p>计算机中的总线主要包括系统总线、内存总线和I&#x2F;O总线等。系统总线连接CPU、内存和I&#x2F;O总线，起控制作用。内存总线连接CPU和内存存储器，用于传输数据和地址信息。I&#x2F;O总线连接CPU和输入输出设备，实现CPU与外部设备的交换。</p><p>总线的性能优化也是计算机体系结构中的重要问题之一。通过提高总线的带宽、信号速度、数据传输效率等方面的优化，可以减少总线的通信时间，从而提高系统的效率和性能。此外，现代计算机中也存在许多高速缓存和矩阵运算单元这样的加速器，它们和传统的CPU、内存之间的数据通信问题也可以通过总线的设计和优化来解决。</p><h3 id="6-阅读扩展资料（著名的争论），说一下你理解的微内核（比如鸿蒙系统）"><a href="#6-阅读扩展资料（著名的争论），说一下你理解的微内核（比如鸿蒙系统）" class="headerlink" title="6.阅读扩展资料（著名的争论），说一下你理解的微内核（比如鸿蒙系统）"></a>6.阅读扩展资料（著名的争论），说一下你理解的微内核（比如鸿蒙系统）</h3><p>答：微内核是一种操作系统内核的设计方式，它将内核的核心功能（如进程管理、内存管理和IPC等）与设备驱动和其他操作系统服务分离开来，以形成一个更加灵活和可扩展的系统架构。与传统的内核设计方式相比，微内核通常更易于维护、升级和扩展，因为内核的大小更加紧凑，内核核心功能的修改也更加容易。</p><p>鸿蒙OS是一款基于微内核设计的操作系统，它采用了名为”Hongmeng”的微内核，这个内核占用内存更少，启动速度更快，能够支持更加广泛的设备和场景。鸿蒙的微内核只提供了最基本的系统功能，而其他服务都是在用户空间或者虚拟空间中运行的，通过进程间通信实现服务的交互。</p><p>微内核设计的优势在于其内核紧凑，扩展性和灵活性更好，而且由于代码的模块化，对中间件和应用开发的支持更好，可以提高生态和用户体验。但是，微内核的缺点也是明显的，因为其进程间通信会使得系统调用相对复杂，增加开发人员的难度。同时，更多的服务需要在用户态运行，也可能导致一些性能问题。</p><p>总结来说，微内核架构的操作系统相对于传统内核设计方式更加灵活，更易于扩展和维护，但它也有一些缺点，需要权衡考虑具体应用场景和需求。</p><h3 id="7-用户态向内核态转有多种情形（用户请求OS提供服务、发生中断、用户进程产生错误、用户态企图执行特权指令），但是本质上就是一种情形，即通过中断的形式进入。如何理解这句话？"><a href="#7-用户态向内核态转有多种情形（用户请求OS提供服务、发生中断、用户进程产生错误、用户态企图执行特权指令），但是本质上就是一种情形，即通过中断的形式进入。如何理解这句话？" class="headerlink" title="7.用户态向内核态转有多种情形（用户请求OS提供服务、发生中断、用户进程产生错误、用户态企图执行特权指令），但是本质上就是一种情形，即通过中断的形式进入。如何理解这句话？"></a>7.用户态向内核态转有多种情形（用户请求OS提供服务、发生中断、用户进程产生错误、用户态企图执行特权指令），但是本质上就是一种情形，即通过中断的形式进入。如何理解这句话？</h3><p>答：这句话表达的是在计算机中，无论是用户请求操作系统提供服务、发生中断、用户进程产生错误、还是用户态尝试执行特权指令，从用户态到内核态的转变本质上都是通过中断的形式实现的。</p><p>当用户态需要向内核态发出请求时，如调用系统调用、请求资源等，用户程序需要将请求参数传递给操作系统，然后通过软中断的方式发起中断请求，从而陷入内核态。在发生硬件中断时，中断控制器会将中断请求发送给CPU，在CPU完成当前指令之后立即停止执行，转而去执行与中断相关的中断处理程序，处理完之后再继续执行之前被打断的指令。</p><p>在用户进程产生错误或企图执行特权指令时，CPU会检测到错误并触发中断。操作系统将会针对不同类型的中断请求执行不同的处理程序，如调用相应的设备驱动程序、分配资源等。</p><p>无论中断请求的源头是什么，用户态到内核态的转变都是通过中断的方式实现的。操作系统需要对中断请求做出及时、正确的响应以保证系统的正常运行。</p><h3 id="8-对Intel-CPU的运行级别和保护模式，特权模式的理解"><a href="#8-对Intel-CPU的运行级别和保护模式，特权模式的理解" class="headerlink" title="8.对Intel CPU的运行级别和保护模式，特权模式的理解"></a>8.对Intel CPU的运行级别和保护模式，特权模式的理解</h3><p>答：Intel CPU的运行级别一般分为四种，分别是Ring 0、Ring 1、Ring 2和Ring 3。Ring 0为内核态，代表CPU最高的权限级别，只有操作系统内核可以运行在这个级别。Ring 1-3代表用户态，权限逐渐降低，Ring 3为最低权限，只有用户程序能够运行在这个级别。</p><p>在Intel CPU中，保护模式是一种特殊的运行模式，用于保护操作系统和用户程序的安全和稳定。这种模式下，CPU使用分段机制对内存进行了保护，使得每个进程只能访问自己的地址空间，从而避免了进程和操作系统之间的相互干扰。此外，保护模式下还支持虚拟内存、分页机制、系统调用等多种特性，使得系统在安全性和性能上都能得到更好的保障。</p><p>在保护模式下的CPU运行级别被称为特权级别，可分为四个级别，分别是Ring 0-3，级别越低的程序拥有越少的权限，不能直接访问CPU、内存等系统资源，只能通过操作系统提供的API调用来访问。Ring 0级别是最高特权级别，代表内核态，只有操作系统内核才能运行在这个级别。Ring 3级别为最低特权级别，代表用户态。操作系统和用户程序都运行在Ring 3以及以上的特权级别，而用户程序不能进入到Ring 0的特权级别中。</p><p>总之，Intel CPU的运行级别和保护模式实现了在计算机系统中的多层次安全保护，保护计算机的威胁和机密信息不被非授权用户访问和修改。</p><hr><h2 id="三-进程概念和进程基本状态，PCB"><a href="#三-进程概念和进程基本状态，PCB" class="headerlink" title="三.进程概念和进程基本状态，PCB"></a>三.进程概念和进程基本状态，PCB</h2><h3 id="1-程序的顺序执行有何特征？为什么有这些特征？"><a href="#1-程序的顺序执行有何特征？为什么有这些特征？" class="headerlink" title="1.程序的顺序执行有何特征？为什么有这些特征？"></a>1.程序的顺序执行有何特征？为什么有这些特征？</h3><p>答：程序的顺序执行主要表现为程序指令的执行顺序是按照程序代码给出的顺序执行，一条指令执行完毕后再执行下一条指令。这种执行方式是计算机硬件根据指令的指针、计数器等控制信息依次读取并执行指令的结果。</p><p>程序的顺序执行主要有以下两个特征：</p><ol><li><p>程序指令是在一条接一条地执行。这种执行方式使得计算机能够按照程序代码的规定顺序来执行每一条指令，确保了程序的正确性，同时也保证了程序的可读性和可维护性。</p></li><li><p>程序的执行过程是一条指令执行完成后再执行下一条指令。这种顺序执行方式使得计算机能够有序地执行程序中的指令，从而确保每个指令的正确执行和正确处理数据。</p></li></ol><p>这些特征的存在是因为计算机的硬件结构和指令的执行原理。在计算机的硬件结构中，CPU负责执行指令的过程，每个指令一般都需要完成一个特定的任务，例如运算、传输、跳转等操作。CPU通过识别指令中的操作码和操作数，依次执行每一条指令中的操作。</p><p>同时，指令的执行需要按照一定的顺序进行，例如控制指令需要优先执行，数据操作指令需要等到数据准备好后才能执行。因此，程序的顺序执行是基于计算机硬件和指令系统的运行原理，以确保指令能够正确地执行、数据能够被正确处理。</p><h3 id="2-进程有什么特征？进程和程序的区别是什么？为何引入进程？"><a href="#2-进程有什么特征？进程和程序的区别是什么？为何引入进程？" class="headerlink" title="2.进程有什么特征？进程和程序的区别是什么？为何引入进程？"></a>2.进程有什么特征？进程和程序的区别是什么？为何引入进程？</h3><p>答：进程(Process)是计算机系统中的一个术语，指在电脑上执行的一段程序。进程具有以下几个特征：</p><ol><li><p>动态性：进程是一个动态的概念，它的生命周期包括创建、运行、等待、挂起、终止等多个状态。</p></li><li><p>并发性：系统中可以存在多个进程同时运行，每个进程都有自己的程序计数器、堆栈等内存空间，互相独立。</p></li><li><p>独立性：每个进程都有自己的地址空间，属于不同的进程之间的变量和程序代码是互不影响的。进程之间可以通过进程间通信机制来实现数据共享和交互。</p></li><li><p>随机性：由于系统中可能存在多个进程，每个进程的执行都受到许多因素的影响，因此进程的执行顺序和时间都是不确定的。</p></li></ol><p>进程与程序的区别是，程序是一个静态的概念，是指一组指令和数据的集合，不具有运行和管理功能。而进程则是对程序的一种运行状态描述，是指在某个特定时间段内，正在执行的程序，并且具有独立的内存空间、CPU时间片、系统分配的CPU资源等，能够独立运行于系统中。</p><p>引入进程主要是为了更加有效的利用计算机资源，同时也方便进程间的互相通信与交互。通过操作系统的进程管理机制，能够保证每个进程可以有适当的时间片并发地执行，并可以得到资源的合理分配和调度，从而充分利用计算机的 CPU 和内存等资源，提高计算机的工作效率和生产力。</p><h3 id="3-程序代码长度和进程大小有没有关系？进程大小如何确定？是否可变？"><a href="#3-程序代码长度和进程大小有没有关系？进程大小如何确定？是否可变？" class="headerlink" title="3.程序代码长度和进程大小有没有关系？进程大小如何确定？是否可变？"></a>3.程序代码长度和进程大小有没有关系？进程大小如何确定？是否可变？</h3><p>答：程序代码长度和进程大小并不是完全相关的，两者的大小并不完全相等。进程的大小一般包括程序代码、数据和内存占用等多方面的因素，大小可以根据需要来确定和调整。</p><p>具体来说，进程的大小主要由以下几个方面的因素共同决定：</p><ol><li><p>程序代码的长度：程序包含指令、函数、库等相关代码，以及数据区、BSS、堆栈等占用内存的相关信息，程序代码的长度大小是影响进程大小的一个因素。</p></li><li><p>数据占用的内存大小：进程中包含的数据结构、变量等都需要占用一定的内存空间，该内存大小也是影响进程大小的一个因素。</p></li><li><p>库和动态链接文件：在进程运行时，可能会使用一些系统库或者动态链接文件，这些文件占用的内存空间也会计入进程的大小。</p></li><li><p>运行时需要占用的堆栈和堆内存：进程在运行时需要占用一定的堆栈和堆内存空间，这些空间也是进程大小的重要组成部分。</p></li></ol><p>进程的大小是动态可变的，因为进程在运行过程中需要动态分配内存空间，可以根据需要来调整进程大小。进程可能会释放占用的内存，也可能会申请新的内存空间，进程大小随之相应地变化。</p><p>总之，进程大小的计算是比较复杂的，并且与具体的应用程序有关。在实际应用过程中，我们需要根据实际应用情况来确定进程大小，并根据需要来动态调整进程的内存大小，以充分利用计算机资源，提高系统性能。</p><h3 id="4-PCB的作用，操作系统的内核代码中什么地方会用到PCB？操作系统的PCB是否相同？PCB的内容由什么来决定？"><a href="#4-PCB的作用，操作系统的内核代码中什么地方会用到PCB？操作系统的PCB是否相同？PCB的内容由什么来决定？" class="headerlink" title="4.PCB的作用，操作系统的内核代码中什么地方会用到PCB？操作系统的PCB是否相同？PCB的内容由什么来决定？"></a>4.PCB的作用，操作系统的内核代码中什么地方会用到PCB？操作系统的PCB是否相同？PCB的内容由什么来决定？</h3><p>答：PCB（Process Control Block）又叫进程控制块，是操作系统中用于描述和管理进程的数据结构，主要用于记录和维护进程的运行状态、环境和资源等信息，是操作系统内核代码管理进程的基础结构。</p><p>PCB的主要作用有以下几个方面：</p><ol><li><p>记录和管理进程的各种状态：PCB中记录了进程的状态信息，包括就绪、运行、阻塞等状态，以及进程的运行优先级、资源占用等信息。</p></li><li><p>维护进程的资源信息：在PCB中记录了进程所占用的系统资源信息，包括内存、文件、设备、锁等等，这些资源由操作系统内核在系统中进行管理。</p></li><li><p>实现进程的调度和切换：系统内核可根据PCB中记录的进程状态信息，进行进程的切换和分配，以保证进程间的调度和资源的充分利用。</p></li><li><p>保护和安全控制：PCB中还包括了进程的安全和保护相关信息，确保进程对系统资源和其他进程的访问不会出现冲突和不当的操作。</p></li></ol><p>操作系统的内核代码中使用PCB主要用于进程的管理和调度。在内核代码中，会通过记录和操作PCB信息来控制进程的运行，包括创建新的进程、启动、挂起、终止等操作。当进程在运行时，操作系统会根据PCB中的信息进行调度，把CPU、内存等资源进行动态分配，以保证进程的正常运行。</p><p>不同进程的PCB是不相同的，每个PCB都记录了进程的独立信息，所以在操作系统中不可能存在两个PCB内容完全相同的进程。PCB的内容由具体的操作系统和应用程序所需的信息来决定，通常PCB包含了进程标识、运行状态、优先级、内存分配信息、资源使用信息等多方面的信息，这些信息都是由操作系统及共用库来决定和协调的。具体来说，不同的操作系统和应用程序的PCB内容和结构可能会有所不同，但它们都具有管理和调度进程的基础结构特征。</p><h3 id="5-解释进程3种基本状态（run，ready，block）的转换哪些可以有，哪些没有，为什么？阻塞能不能直接到运行？如果系统里面只有一个进程呢？"><a href="#5-解释进程3种基本状态（run，ready，block）的转换哪些可以有，哪些没有，为什么？阻塞能不能直接到运行？如果系统里面只有一个进程呢？" class="headerlink" title="5.解释进程3种基本状态（run，ready，block）的转换哪些可以有，哪些没有，为什么？阻塞能不能直接到运行？如果系统里面只有一个进程呢？"></a>5.解释进程3种基本状态（run，ready，block）的转换哪些可以有，哪些没有，为什么？阻塞能不能直接到运行？如果系统里面只有一个进程呢？</h3><p>答：进程通常有三种基本状态：运行态（run）、就绪态（ready）、阻塞态（block），它们之间是互相转换的。但并不是所有状态之间都可以直接转换的，下面分类分析：</p><ol><li><p>可以由 Ready 状态转换到 Run 状态，由运行态进程结束或被阻塞而转化到 Ready 状态，由阻塞状态进程上的事件完成而转化为 Ready 状态，因为 Ready 状态代表了可以运行的状态。</p></li><li><p>不可以由 Run 状态转化为 Ready 状态，因为从运行态进程转化为就绪态进程需要让出 CPU，而在执行期间的进程不能让出 CPU。</p></li><li><p>不可以由 Ready 状态直接变为阻塞态，而是必须经过 Run 状态。当进程运行时，可能会遇到一些等待的事件（如等待文件读写完成），此时进程会变成阻塞态，只有等到事件完成后，再由阻塞态转化为就绪态。</p></li><li><p>不可以直接从阻塞态进入运行态，因为要进入运行态，必须先从阻塞态进入就绪态，然后由就绪态进入运行态。</p><p>当系统只有一个进程时，该进程将一直处于运行状态，不会发生状态之间的转换，因为都是其自己在运行。但是，如果该进程需要等待某个事件的完成，比如输入输出操作，则会进入阻塞状态，直到事件完成为止。</p></li></ol><h3 id="6-进程引入“挂起（suspend）”状态后，原来的3状态中哪些变了？解释加入挂起状态后的状态转换图"><a href="#6-进程引入“挂起（suspend）”状态后，原来的3状态中哪些变了？解释加入挂起状态后的状态转换图" class="headerlink" title="6.进程引入“挂起（suspend）”状态后，原来的3状态中哪些变了？解释加入挂起状态后的状态转换图"></a>6.进程引入“挂起（suspend）”状态后，原来的3状态中哪些变了？解释加入挂起状态后的状态转换图</h3><p>答：引入挂起状态后，原来的三种状态（运行态、就绪态、阻塞态）并没有改变，但是添加了一种新的状态——挂起态，代表进程因某些原因被暂停执行。</p><p>进程状态转换图中，加入了挂起状态后，转换关系如下图所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++">\```<br>         ┌─────────┐<br>         │ Ready │<br>         └─────────┘<br>            │<br>   ┌─────────┐   ▼   ┌───────────┐<br>   │ Running │────────────&gt;│ Suspended │<br>   └─────────┘   │   └───────────┘<br>            ▼      ▲<br>         ┌─────────┐   │<br>         │ Blocked │──────┘<br>         └─────────┘<br>\```<br></code></pre></td></tr></table></figure><p>其中，新增的挂起状态在 Ready 和 Suspended 之间，进程可以从 Ready 状态或者 Running 状态转化到挂起状态，再从挂起状态转化为 Ready 状态或者 Suspended 状态。当从 Running 状态转移到 Suspended 状态时，操作系统会将该进程的上下文信息保存在 PCB 中，以便之后再次运行该进程时，可以恢复上下文信息，继续之前的工作。</p><p>当进程处于 Suspended 状态时，如果发生了进程终止、时间片到期、进程被唤醒等事件，则会从 Suspended 状态转化为 Ready 状态，即进入就绪队列等待 CPU 调度。如果发生了进程等待事件完成的情况，则会由 Suspended 状态转化为 Blocked 状态。</p><p>总之，引入挂起状态后，进程状态的转换更加灵活和多样化，使得操作系统能够更加有效地管理和调度进程，提高计算机的资源利用率和工作效率。</p><h3 id="7-有人说在windows中：“后台程序对应阻塞态，前台是运行态”，给出正确的说法，并结合进程状态转换进行说明"><a href="#7-有人说在windows中：“后台程序对应阻塞态，前台是运行态”，给出正确的说法，并结合进程状态转换进行说明" class="headerlink" title="7.有人说在windows中：“后台程序对应阻塞态，前台是运行态”，给出正确的说法，并结合进程状态转换进行说明"></a>7.有人说在windows中：“后台程序对应阻塞态，前台是运行态”，给出正确的说法，并结合进程状态转换进行说明</h3><p>答：这种说法是不正确的，Windows操作系统中的程序分为两种类型：前台程序和后台程序，它们对应的状态并不是明确的阻塞态或者运行态。实际上，程序的状态是由当前的进程活动（例如是否正在与用户交互）决定的，而与程序的前台或后台特性无关。</p><p>在Windows操作系统中，每个程序（进程）都有自己的进程状态，状态可以是运行态、就绪态、阻塞态和挂起态四种状态中的任意一种，具体状态如下：</p><ol><li><p>运行态：正在执行的进程，占用 CPU 资源。</p></li><li><p>就绪态：已经处于准备运行状态，等待进入运行状态（即等待 CPU 时间片）。</p></li><li><p>阻塞态：正在等待某一事件完成后才能进行运行，如等待系统资源、等待用户输入、等待其他进程的消息等。</p></li><li><p>挂起态：处于挂起状态的进程不处于运行、就绪或阻塞状态，而是被操作系统暂停，直到恢复操作系统对其进行调度。</p><p>因此，一个前台程序可以是运行态、就绪态、阻塞态或挂起态中的任意一种，后台程序也是一样。这取决于当前进程的运行状况，而不是程序本身的前台或者后台特性。</p><p>总之，程序的前台和后台特性并不能直接对应操作系统中的进程状态，进程状态是由该进程的运行情况所决定的。</p></li></ol><h3 id="8-若系统中既没有运行进程，又没有就绪进程，系统中是否就没有进程？说明系统最多有多少运行进程，就绪进程，最少又有多少。如果是多核呢？"><a href="#8-若系统中既没有运行进程，又没有就绪进程，系统中是否就没有进程？说明系统最多有多少运行进程，就绪进程，最少又有多少。如果是多核呢？" class="headerlink" title="8.若系统中既没有运行进程，又没有就绪进程，系统中是否就没有进程？说明系统最多有多少运行进程，就绪进程，最少又有多少。如果是多核呢？"></a>8.若系统中既没有运行进程，又没有就绪进程，系统中是否就没有进程？说明系统最多有多少运行进程，就绪进程，最少又有多少。如果是多核呢？</h3><p>答：即使系统中没有运行或就绪的进程，也可能存活有一些挂起或阻塞中的进程。所以，系统里面并不需要有运行或者就绪的进程，也可能存在挂起或者阻塞的进程。</p><p>在单核处理器的情况下，系统最多只能同时运行一个进程，因为在同一时间只能有一个进程运行在处理器上。而就绪态和阻塞态进程的数量是没有限制的，只受硬件及系统资源的限制。在不断切换进程的情况下，可以有多个就绪态进程等待CPU进行调度。</p><p>在多核处理器的情况下，每个CPU内核都有自己的进程调度器，多个进程可以在不同的核上并行运行，系统最多可以有多个运行态进程同时运行。但是就绪态和阻塞态进程的数量同样是没有限制的，只受硬件及系统资源的限制。</p><p>因此，在单核处理器情况下，运行态最多只有一个进程，就绪态和阻塞态进程数量不限，可以没有就绪和运行态进程，也可能有很多进程处于就绪和阻塞态等待CPU的调度。在多核处理器情况下，运行态进程最多的数量取决于核心数量，就绪态和阻塞态进程数量同样不限制。</p><h3 id="9-什么是原语？进程控制为什么需要原语？不用原语会怎么样？"><a href="#9-什么是原语？进程控制为什么需要原语？不用原语会怎么样？" class="headerlink" title="9.什么是原语？进程控制为什么需要原语？不用原语会怎么样？"></a>9.什么是原语？进程控制为什么需要原语？不用原语会怎么样？</h3><p>答：原语（Primitive）是操作系统提供给应用程序或系统软件的一种基本操作，可以看作是一系列相关操作的集合，操作系统保证了原语的原子性和独占性，一个原语的完成不允许被其他进程打断。典型的原语有进程同步原语、进程互斥原语等等。在原语的作用下，多个进程能够进行有效的协调和同步。</p><p>进程控制需要原语的原因是，进程控制是操作系统的一个核心功能，它涉及到多个进程之间的协调，而多个进程的并发执行会引起很多问题，比如资源竞争、进程间通信等，这时候需要用到原语来解决这些问题，确保数据的一致性和进程的正确运行。例如，在进程并发访问共享资源时，如果没有互斥原语的保护，可能会导致资源竞争、死锁等问题，导致程序的异常终止或程序无法向前运行。</p><p>如果不使用原语进行进程同步和协调，可能会导致进程之间出现各种不一致和错误的情况，比如数据损坏、死锁问题等，甚至可能导致系统崩溃。使用原语，操作系统可以提供一种可靠的机制，确保多线程编程的正确性，提高系统的稳定性和安全性。</p><p>因此，原语在操作系统中是非常重要的，它们为操作系统提供了一些关键的机制，支持进程控制功能的正确实现，确保系统的高性能、高稳定性和高安全性。</p><h3 id="10-进程有就绪队列，阻塞队列，有些系统把阻塞队列分为很多个：不同阻塞原因的进程放在不同的队列。为什么要这么做？有什么好处？"><a href="#10-进程有就绪队列，阻塞队列，有些系统把阻塞队列分为很多个：不同阻塞原因的进程放在不同的队列。为什么要这么做？有什么好处？" class="headerlink" title="10.进程有就绪队列，阻塞队列，有些系统把阻塞队列分为很多个：不同阻塞原因的进程放在不同的队列。为什么要这么做？有什么好处？"></a>10.进程有就绪队列，阻塞队列，有些系统把阻塞队列分为很多个：不同阻塞原因的进程放在不同的队列。为什么要这么做？有什么好处？</h3><p>答：将阻塞队列分为多个不同的队列，是为了更加精细地管理进程，提高系统的性能和效率。具体来说，这种做法可以带来以下几方面的好处：</p><ol><li><p>更精细的进程管理：各个阻塞队列代表了不同类型的阻塞原因，这样可以更加精细地管理进程，针对不同的阻塞原因，采用不同的策略和优化措施，提高系统的效率和性能。</p></li><li><p>提高进程响应速度：将不同原因的阻塞进程分类管理，可以缩短进程的等待时间，快速地查找到满足条件的进程，提高进程响应速度。</p></li><li><p>降低系统开销：将阻塞队列分为若干小队列，尽可能避免了阻塞队列里进程过多导致遍历速度变慢，避免了不必要的系统开销，提高了系统的性能。</p></li><li><p>减少死锁情况的发生：不同的阻塞原因正是导致死锁的原因之一，将不同原因的阻塞进程分别管理，可以避免进程之间产生死锁问题。</p><p> 总之，将阻塞队列分成多个队列，可以更加细致地管理进程，提高系统的性能和效率，降低系统开销，减少死锁情况的发生，增加系统的稳定性和可靠性。</p></li></ol><h3 id="11-Linux创建进程为什么用fork把父进程复制一份？子进程和父进程一样有意义么？Windows是不是这样创建的？这样有什么优点和缺点？"><a href="#11-Linux创建进程为什么用fork把父进程复制一份？子进程和父进程一样有意义么？Windows是不是这样创建的？这样有什么优点和缺点？" class="headerlink" title="11.Linux创建进程为什么用fork把父进程复制一份？子进程和父进程一样有意义么？Windows是不是这样创建的？这样有什么优点和缺点？"></a>11.Linux创建进程为什么用fork把父进程复制一份？子进程和父进程一样有意义么？Windows是不是这样创建的？这样有什么优点和缺点？</h3><p>答：Linux中使用fork系统调用创建进程是由于Unix及其衍生系统的设计理念之一就是“一切皆文件”，进程也不例外。在Unix操作系统下，进程是通过fork系统调用来创建的。</p><p>使用fork将父进程复制一份出来创建子进程，是为了让子进程拥有父进程的所有资源，包括内存空间、文件描述符、信号处理方式等。这就保证了子进程可以使用和修改父进程的资源，也可以独立地运行自己的代码。子进程和父进程在大小和功能上虽然相同，但实际上是两个不同的进程，各自拥有独立的内存空间和资源，相互独立运行。</p><p>Windows中创建进程的方式和Linux有所不同，Windows使用CreateProcess函数创建进程，它会根据指定的程序来创建一个新的进程，程序运行时所需的资源由新进程自己创建，不像fork方式直接将父进程复制一份。</p><p>使用fork创建进程的优点是：</p><ol><li><p>能够高效地创建一个新进程，因为父进程已经有了部分资源，无需重新分配和初始化，也无需重新读取代码段等信息。</p></li><li><p>子进程可以继承父进程的所有资源，包括已打开的文件、文件锁、内存地址空间以及信号处理方式等。</p></li><li><p>实现起来比较简单，使用起来也比较方便。</p></li></ol><p>使用fork创建进程的缺点是：</p><ol><li><p>占用的资源更多，包括内存和CPU等资源。</p></li><li><p>子进程与父进程在一开始的时候是相同的，如果需要让它们区分开来，需要进行一些额外的处理。</p><p> 总的来说，使用fork创建进程的方式能够高效地创建新的进程，且子进程可以继承父进程的资源，使用起来也相对简单，但需要注意父子进程之间的资源竞争和重复计算等问题。而Windows中创建进程的方式则不会出现这些问题，但在创建进程时需要手动设置新进程所需的资源。</p></li></ol><h3 id="12-解释Linux中的孤儿进程和僵尸进程：是进程的什么状态？怎么产生的，有什么作用，危害，演示两种进程"><a href="#12-解释Linux中的孤儿进程和僵尸进程：是进程的什么状态？怎么产生的，有什么作用，危害，演示两种进程" class="headerlink" title="12.解释Linux中的孤儿进程和僵尸进程：是进程的什么状态？怎么产生的，有什么作用，危害，演示两种进程"></a>12.解释Linux中的孤儿进程和僵尸进程：是进程的什么状态？怎么产生的，有什么作用，危害，演示两种进程</h3><p>答：在Linux中，孤儿进程和僵尸进程都是进程的一种状态。</p><p>孤儿进程是指其父进程已经退出（或被杀死），而子进程还在运行的进程。此时，操作系统会将孤儿进程的父进程设置为init进程，让其接管子进程的后续处理工作。孤儿进程并不会影响系统的正常运行，其存在也不会对其他进程造成威胁。</p><p>而僵尸进程则是指进程已经结束，但其父进程没有回收其资源。在这种情况下，该进程的PCB（进程控制块）等信息会保留在系统中一段时间，占用系统资源，导致进程数目增多，从而降低系统的可用性和性能。 </p><p>产生孤儿进程的原因通常是父进程先于子进程退出，导致子进程成为孤儿进程。而僵尸进程通常是因为父进程没有及时回收已退出的子进程，或者父进程本身也退出了，让子进程变成孤儿进程，最终变成僵尸进程。操作系统会自动帮助我们回收子进程的资源，但如果父进程一直没有处理，这些子进程的资源就不会被回收，最终形成僵尸进程。 </p><p>孤儿进程相比于僵尸进程来说，影响相对较小。而僵尸进程的存在会浪费系统资源，导致系统性能下降。 </p><p>下面演示一下两种进程（Python语言）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python">python<br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> time<br><br><span class="hljs-comment"># 创建子进程</span><br>pid = os.fork()<br><br><span class="hljs-comment"># 如果 pid 为 0，则是子进程</span><br><span class="hljs-keyword">if</span> pid == <span class="hljs-number">0</span>:<br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;I am child process and my pid is:&quot;</span>, os.getpid())<br><span class="hljs-keyword">else</span>: <span class="hljs-comment"># 父进程执行此内容</span><br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;I am parent process and my pid is:&quot;</span>, os.getpid())<br>  <span class="hljs-comment"># 等待子进程结束，子进程成为僵尸进程</span><br>  time.sleep(<span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure><p>在上面的代码中，我们使用了fork创建了一个子进程，如果pid为0，则是子进程，否则是父进程。父进程等待5秒钟，此时子进程结束，但父进程却没有回收其资源，从而形成了僵尸进程。</p><h3 id="13-解释和说明使用fork创建10个进程的方法：一个父进程创建10个子进程；或者子进程继续创建子进程。"><a href="#13-解释和说明使用fork创建10个进程的方法：一个父进程创建10个子进程；或者子进程继续创建子进程。" class="headerlink" title="13.解释和说明使用fork创建10个进程的方法：一个父进程创建10个子进程；或者子进程继续创建子进程。"></a>13.解释和说明使用fork创建10个进程的方法：一个父进程创建10个子进程；或者子进程继续创建子进程。</h3><p>答：使用fork创建10个进程的方法可以通过以下两种方式实现：</p><ol><li>一个父进程创建10个子进程：</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>  pid = os.fork()<br>  <span class="hljs-keyword">if</span> pid == <span class="hljs-number">0</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;I am child %d and my pid is %d&quot;</span> % (i+<span class="hljs-number">1</span>, os.getpid()))<br>    exit(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>在这种方式中，我们使用了for循环来创建10个子进程，每个子进程输出自己的编号和进程ID。为了避免子进程也创建新的子进程，我们使用了exit(0)来让子进程结束自己的运行。</p><ol start="2"><li>子进程继续创建子进程：</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">create_process</span>(<span class="hljs-params">num</span>):<br>  <span class="hljs-keyword">if</span> num == <span class="hljs-number">1</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;I am the first child process and my pid is:&quot;</span>, os.getpid())<br>  <span class="hljs-keyword">else</span>:<br>    pid = os.fork()<br>    <span class="hljs-keyword">if</span> pid == <span class="hljs-number">0</span>:<br>      <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;I am child process %d and my pid is %d, my parent pid is %d&quot;</span> % (num, os.getpid(), os.getppid()))<br>    <span class="hljs-keyword">else</span>:<br>      os.wait()<br>      <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Child process %d has terminated&quot;</span> % num)<br>      exit(<span class="hljs-number">0</span>)<br><br><span class="hljs-comment"># 创建第一个子进程</span><br>create_process(<span class="hljs-number">1</span>)<br><br></code></pre></td></tr></table></figure><p>在这种方式中，我们首先创建第一个子进程，然后在create_process函数中，每个子进程都会创建一个新的子进程，直到创建了10个子进程。每个子进程输出自己的编号、进程ID，以及自己的父进程ID。子进程结束时，会输出子进程编号，然后退出自己的运行。</p><p>这两种方式的主要区别在于，第一种方式是父进程创建子进程，而第二种方式是子进程自己继续创建新的子进程。在实际应用中，可以根据具体的需求选择合适的方式来创建多个进程。</p><h3 id="14-浅度睡眠和深度睡眠-TASK-INTERRUPTIBLE-TASK-UNINTERRUPTIBLE-的区别和联系？为什么需要区分？他们的应用场景？能不能把他们合二为一？"><a href="#14-浅度睡眠和深度睡眠-TASK-INTERRUPTIBLE-TASK-UNINTERRUPTIBLE-的区别和联系？为什么需要区分？他们的应用场景？能不能把他们合二为一？" class="headerlink" title="14.浅度睡眠和深度睡眠(TASK_INTERRUPTIBLE TASK_UNINTERRUPTIBLE)的区别和联系？为什么需要区分？他们的应用场景？能不能把他们合二为一？"></a>14.浅度睡眠和深度睡眠(TASK_INTERRUPTIBLE TASK_UNINTERRUPTIBLE)的区别和联系？为什么需要区分？他们的应用场景？能不能把他们合二为一？</h3><p>答：浅度睡眠和深度睡眠是Linux操作系统中进程休眠的两种方式，其中浅度睡眠也称为可中断睡眠（TASK_INTERRUPTIBLE），深度睡眠也称为不可中断睡眠（TASK_UNINTERRUPTIBLE）。</p><p>两种睡眠状态的区别在于，可中断睡眠的进程可以被信号打断而唤醒，而不可中断睡眠的进程则不会被信号打断而唤醒。通常，进程在执行等待某些事件的操作时，会进入睡眠状态，等到事件发生时被唤醒。</p><p>区分浅度睡眠和深度睡眠是为了提高系统效率和避免死锁等问题。因为在等待某些事件时，如果进程一直处于可中断睡眠状态，当出现新的事件时，系统不需要进行额外的操作就可以让进程立即被唤醒，从而提高了系统的响应速度。而不可中断睡眠状态适用于等待某些关键资源，这些资源必须被保证一直可用，如果被其他进程占用或者破坏，可能导致系统不稳定或者崩溃。</p><p>它们的应用场景如下：</p><p>- 可中断睡眠常常在等待一些不是很重要的资源时使用，例如需要读取网络数据或者等待I&#x2F;O设备响应等。</p><p>- 不可中断睡眠常常在等待系统中非常重要的资源或者高优先级的操作时使用，例如等待文件系统上的某个块或者等待磁盘I&#x2F;O完成等。</p><p>将浅度睡眠和深度睡眠合二为一是不可取的。因为这样会影响对资源的细致管理和对系统效率的提升。例如，如果我希望等待某个关键资源始终可用，那么我需要使得进程进入不可中断睡眠状态。如果将这个状态合并到可中断睡眠中就会导致在等待不重要资源时也处于不可中断睡眠状态，这会导致系统的资源浪费和效率降低。因此，需要根据具体情况选择不同的睡眠状态。</p><hr><h2 id="四-线程概念和临界区"><a href="#四-线程概念和临界区" class="headerlink" title="四.线程概念和临界区"></a>四.线程概念和临界区</h2><h3 id="1-同时“画圆”和“画方”，视频是讲用2个线程。如果2个进程，能不能同时“画圆”和“画方”？为什么？"><a href="#1-同时“画圆”和“画方”，视频是讲用2个线程。如果2个进程，能不能同时“画圆”和“画方”？为什么？" class="headerlink" title="1.同时“画圆”和“画方”，视频是讲用2个线程。如果2个进程，能不能同时“画圆”和“画方”？为什么？"></a>1.同时“画圆”和“画方”，视频是讲用2个线程。如果2个进程，能不能同时“画圆”和“画方”？为什么？</h3><p>答：在理论上，两个进程也可以同时“画圆”和“画方”，但实现的难度较大，并且存在更多的问题。主要是由于进程之间的通信和同步需要额外的工作。</p><p>如果两个进程分别执行“画圆”和“画方”这两个任务，则需要通过共享内存、消息队列、信号量等机制进行进程间通信，以便将相关数据和控制信息从一个进程传递到另一个进程中。</p><p>同时，需要考虑进程之间的同步问题。由于进程是独立的执行流，因此不能像线程那样使用锁或条件变量来实现同步。可以使用信号量、管道等机制实现进程之间的同步。</p><p>总之，虽然在理论上两个进程也可以同时“画圆”和“画方”，但是由于需要进行额外的进程间通信和同步，以及实现复杂度较高的并发控制，因此一般情况下使用多线程来实现并发任务更加简单和高效。</p><h3 id="2-线程相对于进程的优点，缺点？"><a href="#2-线程相对于进程的优点，缺点？" class="headerlink" title="2.线程相对于进程的优点，缺点？"></a>2.线程相对于进程的优点，缺点？</h3><p>答：线程相对于进程的优点：</p><ol><li><p>轻量级：线程比进程更加轻量，线程的创建、销毁和切换所需的时间更短，占用的系统资源更少。</p></li><li><p>共享数据：在同一个进程中的所有线程之间可以共享数据，因为它们都在同一个进程的内存空间中，而不需要像进程那样使用IPC机制来进行进程间通信。</p></li><li><p>资源共享和切换效率高：由于线程不像进程那样需要拷贝内存空间和文件句柄等资源，所以线程的切换效率更高，而且同一进程中的线程可以共享系统资源。</p></li><li><p>更快的响应时间：由于线程的创建、销毁和切换所需的时间更短，而且线程之间的通信更加高效，所以线程可以比进程更快地响应用户的请求。</p><p>线程相对于进程的缺点：</p><ol><li><p>容易形成死锁：由于不同的线程可以共享同一块内存空间和资源，所以需要进行严格的同步操作，否则就容易形成死锁。</p></li><li><p>切换复杂度高：线程的切换需要保证共享资源的安全性和正确性，需要进行更多的控制和同步操作，因此线程的编程和调试难度较大。</p></li><li><p>编程难度较高：在多线程编程中，需要考虑很多同步和通信的问题，同时需要避免一些由于线程之间的竞争造成的问题，因此编程难度比单线程编程更高。</p></li><li><p>容易受到并发问题的影响：同一进程中的线程之间共享资源，容易造成线程之间的竞争而导致并发问题，如死锁、信号量竞争等。</p></li></ol><p>综上所述，虽然线程相比进程具有一些优点，但是在使用线程的过程中，需要注意同步和通信的问题，避免产生并发问题，并且需要进行较多的复杂编程和调试工作。同时，线程也无法做到和进程完全分离的隔离，因此需要在具体的应用场景中结合实际情况来选择使用线程还是进程。</p></li></ol><h3 id="3-用户级线程和内核级线程的区别"><a href="#3-用户级线程和内核级线程的区别" class="headerlink" title="3.用户级线程和内核级线程的区别"></a>3.用户级线程和内核级线程的区别</h3><p>答：用户级线程和内核级线程是多线程编程中的两种不同实现方式，它们的区别如下：</p><ol><li><p>实现方式不同。用户级线程是由用户程序库实现的多线程，不需要内核的支持，因此它是基于用户空间的。内核级线程是由操作系统内核支持的多线程，需要使用系统调用来创建和管理线程。</p></li><li><p>线程调度不同。用户级线程的调度是由用户进程自己负责的，所以线程切换的代价比较小。内核级线程的调度是由操作系统内核负责的，因此线程切换的代价比较大，需要进行上下文的切换和内核态和用户态之间的转换。</p></li><li><p>上下文切换的开销不同。用户级线程的上下文切换只是在用户空间中进行的，因此开销比较小。内核级线程的上下文切换要经过内核的介入，因此开销比较大。</p></li><li><p>线程间通信的实现方式不同。由于用户级线程是在用户空间中实现的，线程之间的通信需要使用用户空间的机制，如信号量、管道和共享内存等。而内核级线程的通信需要使用内核空间的机制，如进程间通信(IPC)等。</p></li><li><p>可靠性不同。由于内核级线程是由操作系统内核进行管理的，因此它具有更高的可靠性和稳定性。而由于用户级线程是由用户程序库进行管理的，因此它的可靠性和稳定性较低。</p><p>总之，用户级线程和内核级线程的主要区别在于实现方式、调度、上下文切换的开销、线程间通信的实现方式和可靠性等方面，开发人员需要根据具体应用场景和需求选择使用哪种实现方式。</p></li></ol><h3 id="4-展示多线程编程：全局变量初始值为0，5个线程每个分别-1，5个线程每个分别-1，输出结果"><a href="#4-展示多线程编程：全局变量初始值为0，5个线程每个分别-1，5个线程每个分别-1，输出结果" class="headerlink" title="4.展示多线程编程：全局变量初始值为0，5个线程每个分别+1，5个线程每个分别-1，输出结果"></a>4.展示多线程编程：全局变量初始值为0，5个线程每个分别+1，5个线程每个分别-1，输出结果</h3><p>答：下面是一个用C++实现多线程的例子，实现了全局变量加减的操作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><br><span class="hljs-comment">// 全局变量</span><br><span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> global_var = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 互斥锁</span><br>std::mutex mtx;<br><br><span class="hljs-comment">// 加操作</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add_operation</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000000</span>; i++) &#123;<br>        mtx.<span class="hljs-built_in">lock</span>();<br>        global_var++;<br>        mtx.<span class="hljs-built_in">unlock</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 减操作</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dec_operation</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000000</span>; i++) &#123;<br>        mtx.<span class="hljs-built_in">lock</span>();<br>        global_var--;<br>        mtx.<span class="hljs-built_in">unlock</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 创建加和减的线程</span><br>    std::thread add_threads[<span class="hljs-number">5</span>];<br>    std::thread dec_threads[<span class="hljs-number">5</span>];<br><br>    <span class="hljs-comment">// 启动加和减的线程</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>        add_threads[i] = std::<span class="hljs-built_in">thread</span>(add_operation);<br>        dec_threads[i] = std::<span class="hljs-built_in">thread</span>(dec_operation);<br>    &#125;<br><br>    <span class="hljs-comment">// 等待线程结束</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>        add_threads[i].<span class="hljs-built_in">join</span>();<br>        dec_threads[i].<span class="hljs-built_in">join</span>();<br>    &#125;<br><br>    <span class="hljs-comment">// 输出全局变量</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;global_var: &quot;</span> &lt;&lt; global_var &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上述代码中，我们使用了C++的标准线程库，定义了两个函数add_operation()和dec_operation()，分别执行加操作和减操作，每个线程执行1000000次。使用互斥锁保证线程之间的顺序和操作的正确性。最后输出全局变量的值。由于存在线程之间的竞争和并发问题，因此输出的值可能不是0。</p><h3 id="5-什么是临界资源？举例哪些是临界资源，哪些不是？"><a href="#5-什么是临界资源？举例哪些是临界资源，哪些不是？" class="headerlink" title="5.什么是临界资源？举例哪些是临界资源，哪些不是？"></a>5.什么是临界资源？举例哪些是临界资源，哪些不是？</h3><p>答：临界资源是指在多线程编程中，多个线程同时访问可能导致数据不一致性的共享资源。当且仅当在同一时刻只能被一个线程所操作的共享资源就是临界资源。此时需要使用同步机制（如互斥量、条件变量等）来保证线程安全。</p><p>临界资源的一个重要特点是它的访问必须是互斥的（Mutual Exclusion），即同一时刻只能被一个线程访问或修改。常见的临界资源包括：共享内存、共享数据结构、系统中的网络或IO信息等。例如：</p><ol><li><p>全局变量：在多个线程之间共享的全局变量通常是临界资源，因为多个线程修改全局变量时需要采用同步机制进行互斥访问，否则可能会产生竞态异常。</p></li><li><p>临时变量：线程函数内的私有变量，每个线程之间互不干扰，因此不是临界资源。</p></li><li><p>函数局部变量：每个线程之间，在各自的函数栈空间内，私有独立，线程之间不会产生冲突，也不是临界资源。</p></li><li><p>堆内存和栈内存：存储指针或引用的内存区间可能是临界资源，因为多个线程有可能同时使用该指针或引用，且访问的对象可能互相影响，需要通过同步机制进行访问控制。</p></li><li><p>文件及数据流：多个线程的文件访问会产生竞争，因此文件及数据流也属于临界资源。</p></li></ol><p>总之，临界资源是多线程编程过程中需要关注的重要问题，需要开发人员仔细分析需要同步和保护的资源，制定相应的同步规则和机制，以保证线程的正确并发执行。</p><h3 id="6-什么是临界区？举例说明哪些是临界区，临界区的大小，临界区的数量"><a href="#6-什么是临界区？举例说明哪些是临界区，临界区的大小，临界区的数量" class="headerlink" title="6.什么是临界区？举例说明哪些是临界区，临界区的大小，临界区的数量"></a>6.什么是临界区？举例说明哪些是临界区，临界区的大小，临界区的数量</h3><p>答：临界区是指一个共享资源被多个并发进程或线程同时访问时，可能引发冲突的代码区域。在这个区域内，任意两个进程或线程都不能同时访问共享资源，否则会出现不可预期的结果。</p><p>以下是一些举例说明临界区的情况：</p><ol><li>多个进程或线程同时读写同一个全局变量。</li><li>多个进程或线程同时向同一个文件写入数据。</li><li>多个进程或线程同时访问同一个数据库的某个表。</li></ol><p>临界区的大小取决于代码的具体实现和所涉及的共享资源。例如，在第一个例子中，临界区包含对全局变量进行读写的代码行。在第二个例子中，临界区包含向文件写入数据的代码行。在第三个例子中，临界区包含对数据库表进行读写的代码行。</p><p>临界区的数量也取决于代码的实现和所涉及的共享资源。每个共享资源都可能有一个或多个临界区，这取决于多少个进程或线程需要访问该资源以及如何访问它。因此，具体情况可能会有所不同。</p><h3 id="7-教材p117，代码4-26，这种方式保护临界区有何问题？如下图进行说明提示：在某个地方切换，会不满足“忙则等待”。"><a href="#7-教材p117，代码4-26，这种方式保护临界区有何问题？如下图进行说明提示：在某个地方切换，会不满足“忙则等待”。" class="headerlink" title="7.教材p117，代码4-26，这种方式保护临界区有何问题？如下图进行说明提示：在某个地方切换，会不满足“忙则等待”。"></a>7.教材p117，代码4-26，这种方式保护临界区有何问题？如下图进行说明提示：在某个地方切换，会不满足“忙则等待”。</h3><p>答：变量flag没有进行同步保护：多个线程可能同时访问flag变量，如果不进行同步保护，可能会导致竞态条件（Race Condition）的发生，进而导致线程安全问题。<br>while循环中没有进行休眠操作：如果flag变量一直为true，while循环会一直占用CPU资源，导致系统负载过高。<br>g变量的读写操作没有进行同步保护：多个线程可能同时访问g变量，如果不进行同步保护，可能会导致竞态条件的发生，进而导致线程安全问题。<br>临界区的长度过长：临界区包含了while循环和if语句，且包含了对多个共享变量的访问，临界区的长度过长，会降低程序的并发性能。</p><h3 id="8-2个线程同步对g操作，在某个地方切换，不满足“空闲让进”"><a href="#8-2个线程同步对g操作，在某个地方切换，不满足“空闲让进”" class="headerlink" title="8.2个线程同步对g操作，在某个地方切换，不满足“空闲让进”"></a>8.2个线程同步对g操作，在某个地方切换，不满足“空闲让进”</h3><p>答：空闲让进：当没有任何进程处于临界区的时候，即没有任何进程正在访问临界资源，此时任何访问临界资源的进程都能进入临界区。2个线程同步对g操作，在某个程序段发生了切换，但没有执行空闲让进操作，即此时这段临界区无线程访问。则可能导致进程崩溃或者线程死锁。因此必须设定合理的锁和同步进制，保证线程有序地访问临界资源。同时应该遵循访问临界区的四个准则：忙则等待，空闲让进，优先等待，让权等待，保证程序处于安全的状态。</p><hr><h2 id="五-同步互斥和锁机制"><a href="#五-同步互斥和锁机制" class="headerlink" title="五.同步互斥和锁机制"></a>五.同步互斥和锁机制</h2><h3 id="1-分析：PV解决互斥的视频中，mutex-2时，结果是怎样的"><a href="#1-分析：PV解决互斥的视频中，mutex-2时，结果是怎样的" class="headerlink" title="1.分析：PV解决互斥的视频中，mutex&#x3D;2时，结果是怎样的"></a>1.分析：PV解决互斥的视频中，mutex&#x3D;2时，结果是怎样的</h3><p>答：对于PV问题，P表示生产者，V表示消费者。其中，mutex表示生产者和消费者之间的互斥量，用来保证生产者和消费者之间的同步。</p><p>在PV问题中，当mutex&#x3D;2时，可能存在一些问题，具体情况取决于问题的具体实现。一般来说，mutex&#x3D;2时，可能会出现以下几种情况：</p><ol><li>死锁：如果生产者和消费者都等待对方释放mutex，那么就会出现死锁的情况。此时，程序无法继续执行，需要通过增加互斥量的数量或修改程序逻辑来解决。</li><li>非法访问：如果多个生产者或消费者同时访问共享资源，那么就可能会出现非法访问的情况，导致程序崩溃或数据损坏。此时，需要增加互斥量的数量或修改程序逻辑来解决。</li><li>正常执行：如果互斥量的数量是正确的，那么程序就可以正常执行，生产者和消费者之间可以正确地同步，保证共享资源的安全访问。</li></ol><p>总之，在PV问题中，正确设置互斥量的数量非常重要，可以有效地避免死锁和非法访问等问题，保证程序的正常运行。</p><h3 id="2-生产者消费者问题，改成1个生产者，1个消费者，1个缓冲区"><a href="#2-生产者消费者问题，改成1个生产者，1个消费者，1个缓冲区" class="headerlink" title="2.生产者消费者问题，改成1个生产者，1个消费者，1个缓冲区"></a>2.生产者消费者问题，改成1个生产者，1个消费者，1个缓冲区</h3><p>答：下面是一个简单的C++代码示例，实现了一个生产者消费者问题，其中有一个生产者、一个消费者和一个缓冲区。在这个示例中，缓冲区使用一个队列来保存生产者产生的数据。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;condition_variable&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> BUFFER_SIZE = <span class="hljs-number">5</span>;<br><br>queue&lt;<span class="hljs-type">int</span>&gt; buffer;<br>mutex mtx;<br>condition_variable cond_var;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">producer</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-function">unique_lock&lt;mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mtx)</span></span>;<br>        <span class="hljs-keyword">while</span> (buffer.<span class="hljs-built_in">size</span>() == BUFFER_SIZE) &#123;<br>            <span class="hljs-comment">// 缓冲区已满，等待消费者消费</span><br>            cond_var.<span class="hljs-built_in">wait</span>(lock);<br>        &#125;<br>        <span class="hljs-comment">// 生产者生产数据</span><br>        buffer.<span class="hljs-built_in">push</span>(num++);<br>        cout &lt;&lt; <span class="hljs-string">&quot;Producer produced &quot;</span> &lt;&lt; num &lt;&lt; endl;<br>        <span class="hljs-comment">// 通知消费者可以消费</span><br>        cond_var.<span class="hljs-built_in">notify_one</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">consumer</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-function">unique_lock&lt;mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mtx)</span></span>;<br>        <span class="hljs-keyword">while</span> (buffer.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-comment">// 缓冲区为空，等待生产者生产</span><br>            cond_var.<span class="hljs-built_in">wait</span>(lock);<br>        &#125;<br>        <span class="hljs-comment">// 消费者消费数据</span><br>        <span class="hljs-type">int</span> num = buffer.<span class="hljs-built_in">front</span>();<br>        buffer.<span class="hljs-built_in">pop</span>();<br>        cout &lt;&lt; <span class="hljs-string">&quot;Consumer consumed &quot;</span> &lt;&lt; num &lt;&lt; endl;<br>        <span class="hljs-comment">// 通知生产者可以生产</span><br>        cond_var.<span class="hljs-built_in">notify_one</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">thread <span class="hljs-title">t1</span><span class="hljs-params">(producer)</span></span>;<br>    <span class="hljs-function">thread <span class="hljs-title">t2</span><span class="hljs-params">(consumer)</span></span>;<br>    t1.<span class="hljs-built_in">join</span>();<br>    t2.<span class="hljs-built_in">join</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在这个代码中，生产者线程和消费者线程都处于一个无限循环中。当生产者线程生产完数据后，会通知消费者线程可以消费，然后等待消费者线程消费完数据后再继续生产；当消费者线程消费完数据后，会通知生产者线程可以继续生产，然后等待生产者线程生产完数据后再继续消费。</p><p>其中，使用了互斥量<code>mtx</code>来保证在访问缓冲区时的线程安全，使用了条件变量<code>cond_var</code>来实现生产者和消费者之间的同步。当缓冲区已满时，生产者线程会调用<code>cond_var.wait(lock)</code>来等待消费者线程消费数据，此时会释放<code>mtx</code>，进入睡眠状态；当缓冲区为空时，消费者线程会调用<code>cond_var.wait(lock)</code>来等待生产者线程生产数据，此时会释放<code>mtx</code>，进入睡眠状态。当生产者生产完数据后，会调用<code>cond_var.notify_one()</code>来通知一个正在等待的消费者线程可以消费；当消费者消费完数据后，会调用<code>cond_var.notify_one()</code>来通知一个正在等待的生产者线程可以生产。</p><h3 id="3-生产者消费者问题，改成多个生产者，一个消费者"><a href="#3-生产者消费者问题，改成多个生产者，一个消费者" class="headerlink" title="3.生产者消费者问题，改成多个生产者，一个消费者"></a>3.生产者消费者问题，改成多个生产者，一个消费者</h3><p>答：下面是一个简单的C++代码示例，实现了一个生产者消费者问题，其中有多个生产者和一个消费者。在这个示例中，缓冲区使用一个队列来保存生产者产生的数据。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;condition_variable&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> BUFFER_SIZE = <span class="hljs-number">5</span>;<br><br>queue&lt;<span class="hljs-type">int</span>&gt; buffer;<br>mutex mtx;<br>condition_variable cond_var;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">producer</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> </span>&#123;<br>    <span class="hljs-type">int</span> num = id * <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-function">unique_lock&lt;mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mtx)</span></span>;<br>        <span class="hljs-keyword">while</span> (buffer.<span class="hljs-built_in">size</span>() == BUFFER_SIZE) &#123;<br>            <span class="hljs-comment">// 缓冲区已满，等待消费者消费</span><br>            cond_var.<span class="hljs-built_in">wait</span>(lock);<br>        &#125;<br>        <span class="hljs-comment">// 生产者生产数据</span><br>        buffer.<span class="hljs-built_in">push</span>(num++);<br>        cout &lt;&lt; <span class="hljs-string">&quot;Producer &quot;</span> &lt;&lt; id &lt;&lt; <span class="hljs-string">&quot; produced &quot;</span> &lt;&lt; num &lt;&lt; endl;<br>        <span class="hljs-comment">// 通知消费者可以消费</span><br>        cond_var.<span class="hljs-built_in">notify_one</span>();<br>        lock.<span class="hljs-built_in">unlock</span>();<br>        this_thread::<span class="hljs-built_in">sleep_for</span>(chrono::<span class="hljs-built_in">milliseconds</span>(<span class="hljs-number">1000</span>));<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">consumer</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-function">unique_lock&lt;mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mtx)</span></span>;<br>        <span class="hljs-keyword">while</span> (buffer.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-comment">// 缓冲区为空，等待生产者生产</span><br>            cond_var.<span class="hljs-built_in">wait</span>(lock);<br>        &#125;<br>        <span class="hljs-comment">// 消费者消费数据</span><br>        <span class="hljs-type">int</span> num = buffer.<span class="hljs-built_in">front</span>();<br>        buffer.<span class="hljs-built_in">pop</span>();<br>        cout &lt;&lt; <span class="hljs-string">&quot;Consumer consumed &quot;</span> &lt;&lt; num &lt;&lt; endl;<br>        <span class="hljs-comment">// 通知生产者可以生产</span><br>        cond_var.<span class="hljs-built_in">notify_one</span>();<br>        lock.<span class="hljs-built_in">unlock</span>();<br>        this_thread::<span class="hljs-built_in">sleep_for</span>(chrono::<span class="hljs-built_in">milliseconds</span>(<span class="hljs-number">1000</span>));<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> NUM_PRODUCERS = <span class="hljs-number">3</span>;<br>    thread producers[NUM_PRODUCERS];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; NUM_PRODUCERS; i++) &#123;<br>        producers[i] = <span class="hljs-built_in">thread</span>(producer, i);<br>    &#125;<br>    <span class="hljs-function">thread <span class="hljs-title">consumer_thread</span><span class="hljs-params">(consumer)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; NUM_PRODUCERS; i++) &#123;<br>        producers[i].<span class="hljs-built_in">join</span>();<br>    &#125;<br>    consumer_thread.<span class="hljs-built_in">join</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在这个代码中，有多个生产者线程和一个消费者线程，生产者线程通过传入的id来区分不同的生产者。当生产者线程生产完数据后，会通知消费者线程可以消费，然后等待消费者线程消费完数据后再继续生产；当消费者线程消费完数据后，会通知生产者线程可以继续生产，然后等待生产者线程生产完数据后再继续消费。</p><p>其中，使用了互斥量<code>mtx</code>来保证在访问缓冲区时的线程安全，使用了条件变量<code>cond_var</code>来实现生产者和消费者之间的同步。当缓冲区已满时，生产者线程会调用<code>cond_var.wait(lock)</code>来等待消费者线程消费数据，此时会释放<code>mtx</code>，进入睡眠状态；当缓冲区为空时，消费者线程会调用<code>cond_var.wait(lock)</code>来等待生产者线程生产数据，此时会释放&#96;</p><h3 id="4-生产者消费者问题，修改限制：生成者和消费者可以同时进入缓冲区"><a href="#4-生产者消费者问题，修改限制：生成者和消费者可以同时进入缓冲区" class="headerlink" title="4.生产者消费者问题，修改限制：生成者和消费者可以同时进入缓冲区"></a>4.生产者消费者问题，修改限制：生成者和消费者可以同时进入缓冲区</h3><p>答：在原先的生产者消费者问题中，生产者和消费者必须轮流地进入缓冲区，这会导致一些不必要的等待。如果我们允许生产者和消费者同时进入缓冲区，就可以更高效地利用资源。下面是一个简单的C++代码示例，实现了一个允许生产者和消费者同时进入缓冲区的生产者消费者问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;condition_variable&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> BUFFER_SIZE = <span class="hljs-number">5</span>;<br><br>queue&lt;<span class="hljs-type">int</span>&gt; buffer;<br>mutex mtx;<br>condition_variable cond_var;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">producer</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> </span>&#123;<br>    <span class="hljs-type">int</span> num = id * <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-function">unique_lock&lt;mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mtx)</span></span>;<br>        <span class="hljs-keyword">while</span> (buffer.<span class="hljs-built_in">size</span>() == BUFFER_SIZE) &#123;<br>            <span class="hljs-comment">// 缓冲区已满，等待消费者消费</span><br>            cond_var.<span class="hljs-built_in">wait</span>(lock);<br>        &#125;<br>        <span class="hljs-comment">// 生产者生产数据</span><br>        buffer.<span class="hljs-built_in">push</span>(num++);<br>        cout &lt;&lt; <span class="hljs-string">&quot;Producer &quot;</span> &lt;&lt; id &lt;&lt; <span class="hljs-string">&quot; produced &quot;</span> &lt;&lt; num &lt;&lt; endl;<br>        <span class="hljs-comment">// 通知消费者可以消费</span><br>        cond_var.<span class="hljs-built_in">notify_one</span>();<br>        lock.<span class="hljs-built_in">unlock</span>();<br>        <span class="hljs-comment">// 生产者进入缓冲区</span><br>        this_thread::<span class="hljs-built_in">sleep_for</span>(chrono::<span class="hljs-built_in">milliseconds</span>(<span class="hljs-number">500</span>));<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">consumer</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-function">unique_lock&lt;mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mtx)</span></span>;<br>        <span class="hljs-keyword">if</span> (buffer.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-comment">// 缓冲区为空，等待生产者生产</span><br>            cond_var.<span class="hljs-built_in">wait</span>(lock);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 消费者消费数据</span><br>            <span class="hljs-type">int</span> num = buffer.<span class="hljs-built_in">front</span>();<br>            buffer.<span class="hljs-built_in">pop</span>();<br>            cout &lt;&lt; <span class="hljs-string">&quot;Consumer &quot;</span> &lt;&lt; id &lt;&lt; <span class="hljs-string">&quot; consumed &quot;</span> &lt;&lt; num &lt;&lt; endl;<br>            <span class="hljs-comment">// 通知生产者可以生产</span><br>            cond_var.<span class="hljs-built_in">notify_one</span>();<br>            lock.<span class="hljs-built_in">unlock</span>();<br>            <span class="hljs-comment">// 消费者进入缓冲区</span><br>            this_thread::<span class="hljs-built_in">sleep_for</span>(chrono::<span class="hljs-built_in">milliseconds</span>(<span class="hljs-number">500</span>));<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> NUM_PRODUCERS = <span class="hljs-number">3</span>;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> NUM_CONSUMERS = <span class="hljs-number">2</span>;<br>    thread producers[NUM_PRODUCERS];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; NUM_PRODUCERS; i++) &#123;<br>        producers[i] = <span class="hljs-built_in">thread</span>(producer, i);<br>    &#125;<br>    thread consumers[NUM_CONSUMERS];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; NUM_CONSUMERS; i++) &#123;<br>        consumers[i] = <span class="hljs-built_in">thread</span>(consumer, i);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; NUM_PRODUCERS; i++) &#123;<br>        producers[i].<span class="hljs-built_in">join</span>();<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; NUM_CONSUMERS; i++) &#123;<br>        consumers[i].<span class="hljs-built_in">join</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在这个代码中，有多个生产者线程和一个消费者线程，生产者线程通过传入的id来区分不同的生产者。当生产者线程生产完数据后，会通知消费者线程可以消费，然后等待消费者线程消费完数据后再继续生产；当消费者线程消费完数据后，会通知生产者线程可以继续生产，然后等待生产者线程生产完数据后再继续消费。</p><h3 id="5-生产者消费者问题，生产者两个P操作-P-empty-和-P-mutex-交换，其他不变，会是怎样的结果？"><a href="#5-生产者消费者问题，生产者两个P操作-P-empty-和-P-mutex-交换，其他不变，会是怎样的结果？" class="headerlink" title="5.生产者消费者问题，生产者两个P操作( P(empty) 和 P(mutex) )交换，其他不变，会是怎样的结果？"></a>5.生产者消费者问题，生产者两个P操作( P(empty) 和 P(mutex) )交换，其他不变，会是怎样的结果？</h3><p>答：在标准的生产者消费者问题中，通常使用两个信号量<code>empty</code>和<code>full</code>来表示缓冲区的状态。其中，<code>empty</code>表示缓冲区为空的资源数，当生产者向缓冲区中生产数据时，需要获取<code>empty</code>信号量，如果<code>empty</code>信号量为0，则生产者需要等待；<code>full</code>表示缓冲区为满的资源数，当消费者从缓冲区中消费数据时，需要获取<code>full</code>信号量，如果<code>full</code>信号量为0，则消费者需要等待。</p><p>如果将生产者的两个P操作( P(empty) 和 P(mutex) )交换，其他不变，会导致以下问题：</p><ol><li>生产者在获取<code>empty</code>信号量之前，已经获取了<code>mutex</code>互斥信号量，这意味着生产者可以访问缓冲区，但是缓冲区可能已经满了，如果此时生产者向缓冲区中写入数据，会导致数据覆盖和丢失。</li><li>如果生产者获取了<code>empty</code>信号量之后，才去获取<code>mutex</code>互斥信号量，那么生产者在获取<code>mutex</code>信号量之前，其他生产者或消费者可能已经访问了缓冲区，此时生产者需要等待，这样会导致生产者无法及时将数据写入缓冲区，从而降低系统的效率。</li></ol><p>因此，交换生产者的两个P操作( P(empty) 和 P(mutex) )会导致生产者在访问缓冲区时存在问题，可能会导致数据不一致或竞态条件的问题。</p><h3 id="6-生产者消费者问题，生产者两个P操作和消费者两个P操作同时交换顺序，会是怎样的结果"><a href="#6-生产者消费者问题，生产者两个P操作和消费者两个P操作同时交换顺序，会是怎样的结果" class="headerlink" title="6.生产者消费者问题，生产者两个P操作和消费者两个P操作同时交换顺序，会是怎样的结果?"></a>6.生产者消费者问题，生产者两个P操作和消费者两个P操作同时交换顺序，会是怎样的结果?</h3><p>答：如果将生产者的两个P操作和消费者的两个P操作同时交换顺序，会导致以下问题：</p><ol><li>生产者先执行P(mutex)操作，获取了缓冲区的互斥信号量，但此时缓冲区可能已经满了，如果生产者此时向缓冲区中写入数据，会导致数据覆盖和丢失。</li><li>消费者先执行P(empty)操作，获取了缓冲区的空闲资源数，但此时缓冲区可能为空，如果消费者此时从缓冲区中读取数据，会导致读取到错误的数据或者出现死锁的情况。</li></ol><p>因此，生产者的两个P操作和消费者的两个P操作同时交换顺序是不正确的，可能会导致生产者和消费者无法正常访问缓冲区，从而导致系统的异常和效率降低。</p><h3 id="7-用信号量实现前驱图："><a href="#7-用信号量实现前驱图：" class="headerlink" title="7.用信号量实现前驱图："></a>7.用信号量实现前驱图：</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml">假设以下6个进程，每个进程中某个时刻要执行的运算语句如下：<br>S1: a = 3+4；<br>S2: b = 2+1；<br>S3: c = a-b；<br>S4: w = c+1；<br> S5: t = c+a<br> S6: z = w+t<br>信号量实现进程的前趋关系<br>提示：第1步，画出前驱图；第2步：图上写出信号量；第3步：伪代码写出程序<br></code></pre></td></tr></table></figure><p>答：前驱图如下所示：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust">P1       P2       P3       P4       P5       P6<br>|        |        |        |        |        |<br>S1       S2       S3       S4       S5       S6<br>|        |        |        |        |        |<br>+---<span class="hljs-punctuation">-&gt;</span>---+--<span class="hljs-punctuation">-&gt;</span>----+--<span class="hljs-punctuation">-&gt;</span>----+--<span class="hljs-punctuation">-&gt;</span>----+--<span class="hljs-punctuation">-&gt;</span>----+<br></code></pre></td></tr></table></figure><ol><li>根据前驱图，可以定义以下信号量：</li></ol><ul><li>sem1：用于P2等待P1执行完S1。</li><li>sem2：用于P3等待P1和P2执行完S1和S2。</li><li>sem3：用于P4等待P3执行完S3。</li><li>sem4：用于P5等待P3和P4执行完S3和S4。</li><li>sem5：用于P6等待P4和P5执行完S4和S5。</li></ul><ol><li>根据以上信号量，可以写出如下伪代码程序：</li></ol><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs scss">scssCopy codesemaphore sem1 = <span class="hljs-number">0</span>; <span class="hljs-comment">// 初始化为0</span><br>semaphore sem2 = <span class="hljs-number">0</span>; <span class="hljs-comment">// 初始化为0</span><br>semaphore sem3 = <span class="hljs-number">0</span>; <span class="hljs-comment">// 初始化为0</span><br>semaphore sem4 = <span class="hljs-number">0</span>; <span class="hljs-comment">// 初始化为0</span><br>semaphore sem5 = <span class="hljs-number">0</span>; <span class="hljs-comment">// 初始化为0</span><br><br>process P1 &#123;<br>    S1;<br>    <span class="hljs-built_in">V</span>(sem1); <span class="hljs-comment">// S1执行完后释放sem1</span><br>&#125;<br><br>process P2 &#123;<br>    <span class="hljs-selector-tag">P</span>(sem1); <span class="hljs-comment">// 等待sem1</span><br>    S2;<br>    <span class="hljs-built_in">V</span>(sem2); <span class="hljs-comment">// S2执行完后释放sem2</span><br>&#125;<br><br>process P3 &#123;<br>    <span class="hljs-selector-tag">P</span>(sem1); <span class="hljs-comment">// 等待sem1</span><br>    <span class="hljs-selector-tag">P</span>(sem2); <span class="hljs-comment">// 等待sem2</span><br>    S3;<br>    <span class="hljs-built_in">V</span>(sem3); <span class="hljs-comment">// S3执行完后释放sem3</span><br>&#125;<br><br>process P4 &#123;<br>    <span class="hljs-selector-tag">P</span>(sem3); <span class="hljs-comment">// 等待sem3</span><br>    S4;<br>    <span class="hljs-built_in">V</span>(sem4); <span class="hljs-comment">// S4执行完后释放sem4</span><br>&#125;<br><br>process P5 &#123;<br>    <span class="hljs-selector-tag">P</span>(sem3); <span class="hljs-comment">// 等待sem3</span><br>    <span class="hljs-selector-tag">P</span>(sem4); <span class="hljs-comment">// 等待sem4</span><br>    S5;<br>    <span class="hljs-built_in">V</span>(sem5); <span class="hljs-comment">// S5执行完后释放sem5</span><br>&#125;<br><br>process P6 &#123;<br>    <span class="hljs-selector-tag">P</span>(sem4); <span class="hljs-comment">// 等待sem4</span><br>    <span class="hljs-selector-tag">P</span>(sem5); <span class="hljs-comment">// 等待sem5</span><br>    S6;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上述程序中，每个进程在执行到需要等待的语句时，会通过P操作来等待其前驱进程完成，通过V操作来唤醒其后继进程。每个进程在完成任务后，会释放相应的信号量，以允许其后继进程继续执行。</p><h3 id="8-过桥问题：独木桥，同一方向的行人可连续过桥，当某一方向有人过桥时，另一方向的行人必须等待；当某一方向无人过桥时，另一方向的行人可以过桥。将独木桥的两个方向分别标记为-A-和-B；两个进程分别是PA和PB。用PV操作性，写出伪代码，解决过桥问题。"><a href="#8-过桥问题：独木桥，同一方向的行人可连续过桥，当某一方向有人过桥时，另一方向的行人必须等待；当某一方向无人过桥时，另一方向的行人可以过桥。将独木桥的两个方向分别标记为-A-和-B；两个进程分别是PA和PB。用PV操作性，写出伪代码，解决过桥问题。" class="headerlink" title="8.过桥问题：独木桥，同一方向的行人可连续过桥，当某一方向有人过桥时，另一方向的行人必须等待；当某一方向无人过桥时，另一方向的行人可以过桥。将独木桥的两个方向分别标记为 A 和 B；两个进程分别是PA和PB。用PV操作性，写出伪代码，解决过桥问题。"></a>8.过桥问题：独木桥，同一方向的行人可连续过桥，当某一方向有人过桥时，另一方向的行人必须等待；当某一方向无人过桥时，另一方向的行人可以过桥。将独木桥的两个方向分别标记为 A 和 B；两个进程分别是PA和PB。用PV操作性，写出伪代码，解决过桥问题。</h3><p>答：以下是使用PV操作解决过桥问题的伪代码：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// 初始化过桥状态为A方向</span><br>state = &quot;<span class="hljs-selector-tag">A</span>&quot;<br><br><span class="hljs-comment">// 定义计数信号量</span><br>num_people_on_bridge = <span class="hljs-number">0</span><br>mutex = <span class="hljs-number">1</span><br><br><span class="hljs-comment">// 定义PV操作函数</span><br>function <span class="hljs-selector-tag">P</span>(semaphore):<br>    while semaphore &lt;= <span class="hljs-number">0</span>:<br>        // 等待信号量可用<br>    semaphore -= <span class="hljs-number">1</span><br><br>function <span class="hljs-built_in">V</span>(semaphore):<br>    semaphore += <span class="hljs-number">1</span><br><br>// 定义A方向过桥函数<br>function <span class="hljs-built_in">cross_bridge_A</span>():<br>    <span class="hljs-built_in">P</span>(mutex)<br>    while num_people_on_bridge &gt; <span class="hljs-number">0</span> or state == <span class="hljs-string">&quot;B&quot;</span>:<br>        // 等待A方向可以过桥的状态<br>        <span class="hljs-built_in">V</span>(mutex)<br>        <span class="hljs-built_in">P</span>(mutex)<br>    num_people_on_bridge += <span class="hljs-number">1</span><br>    state = <span class="hljs-string">&quot;B&quot;</span><br>    <span class="hljs-built_in">V</span>(mutex)<br><br>    // 过桥操作<br>    // ...<br><br>    <span class="hljs-built_in">P</span>(mutex)<br>    num_people_on_bridge -= <span class="hljs-number">1</span><br>    if num_people_on_bridge == <span class="hljs-number">0</span>:<br>        state = <span class="hljs-string">&quot;A&quot;</span><br>    <span class="hljs-built_in">V</span>(mutex)<br><br>// 定义B方向过桥函数<br>function <span class="hljs-built_in">cross_bridge_B</span>():<br>    <span class="hljs-built_in">P</span>(mutex)<br>    while num_people_on_bridge &gt; <span class="hljs-number">0</span> or state == <span class="hljs-string">&quot;A&quot;</span>:<br>        // 等待B方向可以过桥的状态<br>        <span class="hljs-built_in">V</span>(mutex)<br>        <span class="hljs-built_in">P</span>(mutex)<br>    num_people_on_bridge += <span class="hljs-number">1</span><br>    state = <span class="hljs-string">&quot;A&quot;</span><br>    <span class="hljs-built_in">V</span>(mutex)<br><br>    // 过桥操作<br>    // ...<br><br>    <span class="hljs-built_in">P</span>(mutex)<br>    num_people_on_bridge -= <span class="hljs-number">1</span><br>    if num_people_on_bridge == <span class="hljs-number">0</span>:<br>        state = <span class="hljs-string">&quot;B&quot;</span><br>    <span class="hljs-built_in">V</span>(mutex)<br><br>// 初始化行人数组<br>people = [<span class="hljs-string">&quot;A1&quot;</span>, <span class="hljs-string">&quot;A2&quot;</span>, <span class="hljs-string">&quot;A3&quot;</span>, <span class="hljs-string">&quot;B1&quot;</span>, <span class="hljs-string">&quot;B2&quot;</span>, <span class="hljs-string">&quot;B3&quot;</span>]<br><br>// 启动过桥进程<br>for i = <span class="hljs-number">1</span> to <span class="hljs-built_in">length</span>(people):<br>    if people[i][<span class="hljs-number">0</span>] == <span class="hljs-string">&quot;A&quot;</span>:<br>        <span class="hljs-built_in">start_process</span>(cross_bridge_A)<br>    else:<br>        <span class="hljs-built_in">start_process</span>(cross_bridge_B)<br><br></code></pre></td></tr></table></figure><p>在上述代码中，使用一个计数信号量 <code>num_people_on_bridge</code> 来记录桥上的人数，使用一个互斥信号量 <code>mutex</code> 来保证多个进程不会同时修改共享变量。<code>state</code> 变量用于记录当前过桥的方向，A 或 B。在过桥前，每个进程会先等待当前方向可以过桥的状态，然后执行过桥操作，并在过桥后更新桥上的人数和当前过桥的方向。最后，所有行人的过桥操作在多个进程中并发执行。</p><h3 id="9-独木桥问题继续：桥最多承载M个人，如何解决"><a href="#9-独木桥问题继续：桥最多承载M个人，如何解决" class="headerlink" title="9.独木桥问题继续：桥最多承载M个人，如何解决?"></a>9.独木桥问题继续：桥最多承载M个人，如何解决?</h3><p>答：以下是使用PV操作解决过桥问题，并且限制桥最多承载M个人的伪代码：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// 初始化过桥状态为A方向</span><br>state = &quot;<span class="hljs-selector-tag">A</span>&quot;<br><br><span class="hljs-comment">// 定义计数信号量和限制信号量</span><br>num_people_on_bridge = <span class="hljs-number">0</span><br>max_people_on_bridge = M<br>mutex = <span class="hljs-number">1</span><br><br><span class="hljs-comment">// 定义PV操作函数</span><br>function <span class="hljs-selector-tag">P</span>(semaphore):<br>    while semaphore &lt;= <span class="hljs-number">0</span>:<br>        // 等待信号量可用<br>    semaphore -= <span class="hljs-number">1</span><br><br>function <span class="hljs-built_in">V</span>(semaphore):<br>    semaphore += <span class="hljs-number">1</span><br><br>// 定义A方向过桥函数<br>function <span class="hljs-built_in">cross_bridge_A</span>():<br>    <span class="hljs-built_in">P</span>(mutex)<br>    while num_people_on_bridge &gt;= max_people_on_bridge or state == <span class="hljs-string">&quot;B&quot;</span>:<br>        // 等待A方向可以过桥的状态<br>        <span class="hljs-built_in">V</span>(mutex)<br>        <span class="hljs-built_in">P</span>(mutex)<br>    num_people_on_bridge += <span class="hljs-number">1</span><br>    state = <span class="hljs-string">&quot;B&quot;</span><br>    <span class="hljs-built_in">V</span>(mutex)<br><br>    // 过桥操作<br>    // ...<br><br>    <span class="hljs-built_in">P</span>(mutex)<br>    num_people_on_bridge -= <span class="hljs-number">1</span><br>    if num_people_on_bridge == <span class="hljs-number">0</span>:<br>        state = <span class="hljs-string">&quot;A&quot;</span><br>    <span class="hljs-built_in">V</span>(mutex)<br><br>// 定义B方向过桥函数<br>function <span class="hljs-built_in">cross_bridge_B</span>():<br>    <span class="hljs-built_in">P</span>(mutex)<br>    while num_people_on_bridge &gt;= max_people_on_bridge or state == <span class="hljs-string">&quot;A&quot;</span>:<br>        // 等待B方向可以过桥的状态<br>        <span class="hljs-built_in">V</span>(mutex)<br>        <span class="hljs-built_in">P</span>(mutex)<br>    num_people_on_bridge += <span class="hljs-number">1</span><br>    state = <span class="hljs-string">&quot;A&quot;</span><br>    <span class="hljs-built_in">V</span>(mutex)<br><br>    // 过桥操作<br>    // ...<br><br>    <span class="hljs-built_in">P</span>(mutex)<br>    num_people_on_bridge -= <span class="hljs-number">1</span><br>    if num_people_on_bridge == <span class="hljs-number">0</span>:<br>        state = <span class="hljs-string">&quot;B&quot;</span><br>    <span class="hljs-built_in">V</span>(mutex)<br><br>// 初始化行人数组<br>people = [<span class="hljs-string">&quot;A1&quot;</span>, <span class="hljs-string">&quot;A2&quot;</span>, <span class="hljs-string">&quot;A3&quot;</span>, <span class="hljs-string">&quot;B1&quot;</span>, <span class="hljs-string">&quot;B2&quot;</span>, <span class="hljs-string">&quot;B3&quot;</span>]<br><br>// 启动过桥进程<br>for i = <span class="hljs-number">1</span> to <span class="hljs-built_in">length</span>(people):<br>    if people[i][<span class="hljs-number">0</span>] == <span class="hljs-string">&quot;A&quot;</span>:<br>        <span class="hljs-built_in">start_process</span>(cross_bridge_A)<br>    else:<br>        <span class="hljs-built_in">start_process</span>(cross_bridge_B)<br><br></code></pre></td></tr></table></figure><p>在上述代码中，增加了一个限制信号量 <code>max_people_on_bridge</code>，用于限制桥上最多可以承载多少人。在过桥前，每个进程会先等待当前方向可以过桥的状态和桥上人数没有超过限制的状态，然后执行过桥操作，并在过桥后更新桥上的人数和当前过桥的方向。最后，所有行人的过桥操作在多个进程中并发执行。</p><p>需要注意的是，如果桥上的人数已经达到了限制，则进程需要等待另一个方向的进程先过桥，以保证桥上的人数不会超过限制。</p><h3 id="10-对应同步机制4个准则，讲解peterson算法"><a href="#10-对应同步机制4个准则，讲解peterson算法" class="headerlink" title="10.对应同步机制4个准则，讲解peterson算法"></a>10.对应同步机制4个准则，讲解peterson算法</h3><p>答：Peterson算法是一种经典的用于实现共享资源的互斥访问的算法，它是由Computer Science领域的Gary L. Peterson在1981年提出的。Peterson算法是一种软件解决方案，因此它不需要硬件支持，而且它比硬件实现的解决方案更具有可移植性和灵活性。</p><p>Peterson算法遵循了同步机制的四个准则：</p><ol><li>互斥访问：任何时刻只有一个进程可以访问共享资源。</li><li>空闲让进：如果没有进程访问共享资源，则任何试图访问共享资源的进程都可以立即访问。</li><li>忙则等待：如果有进程正在访问共享资源，则试图访问共享资源的进程必须等待。</li><li>有限等待：如果没有进程正在访问共享资源，则进程必须有限时间内进入临界区。</li></ol><p>Peterson算法的核心是使用两个变量 <code>turn</code> 和 <code>flag</code> 来保证互斥访问。其中，<code>turn</code> 变量表示当前访问共享资源的进程，<code>flag</code> 变量表示当前进程是否要访问共享资源。当一个进程想要访问共享资源时，它会设置 <code>flag</code> 为 <code>true</code>，并将 <code>turn</code> 设置为另一个进程的编号。然后，它会进入一个循环，等待另一个进程的 <code>flag</code> 为 <code>false</code>，并且 <code>turn</code> 为自己的编号。如果等待成功，进程就可以进入临界区，访问共享资源。当访问结束后，进程会将 <code>flag</code> 设置为 <code>false</code>，表示不再需要访问共享资源。</p><p>以下是Peterson算法的伪代码：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// 定义两个进程的编号，这里假设进程0和进程1要访问共享资源</span><br>const int P0 = <span class="hljs-number">0</span>;<br>const int P1 = <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">// 定义两个标志变量和一个turn变量</span><br>bool flag<span class="hljs-selector-attr">[2]</span> = &#123;false, false&#125;;<br>int turn = P0;<br><br><span class="hljs-comment">// 进程0想要访问共享资源</span><br>flag<span class="hljs-selector-attr">[P0]</span> = true;<br>turn = P1;<br>while (flag[P1] &amp;&amp; turn == P1) &#123;<br>    <span class="hljs-comment">// 等待进程1释放共享资源</span><br>&#125;<br><span class="hljs-comment">// 进入临界区，访问共享资源</span><br>...<br><span class="hljs-comment">// 退出临界区，释放共享资源</span><br>flag<span class="hljs-selector-attr">[P0]</span> = false;<br><br><span class="hljs-comment">// 进程1想要访问共享资源</span><br>flag<span class="hljs-selector-attr">[P1]</span> = true;<br>turn = P0;<br>while (flag[P0] &amp;&amp; turn == P0) &#123;<br>    <span class="hljs-comment">// 等待进程0释放共享资源</span><br>&#125;<br><span class="hljs-comment">// 进入临界区，访问共享资源</span><br>...<br><span class="hljs-comment">// 退出临界区，释放共享资源</span><br>flag<span class="hljs-selector-attr">[P1]</span> = false;<br></code></pre></td></tr></table></figure><p>以上代码中，<code>flag</code> 数组表示进程是否想要访问共享资源，<code>turn</code> 变量表示当前的进程编号。当进程想要访问共享资源时，它会先将自己的 <code>flag</code> 设置为 <code>true</code>，并将 <code>turn</code> 设置为另一个进程的编号。然后，它会进入一个循环，等待另一个进程的 <code>flag</code> 为 <code>false</code>，并且 <code>turn</code> 为自己的编号。如果等待成功，进程就可以进入临界区，访问共享资源。当访问结束后，进程会将自己的 <code>flag</code> 设置为 <code>false</code>，表示不再需要访问共享资源。</p><p>需要注意的是，Peterson算法可以保证互斥访问，但是它不能保证公平性。即使一个进程一直在等待，也不能保证下一个进程一定会获得访问共享资源的机会。因此，在实际应用中，我们可能需要使用更加高级的算法来保证公平性。</p><hr><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>欢迎您，请进🏝️🏝️🏝️</title>
    <link href="/2023/09/27/%E6%AC%A2%E8%BF%8E%E6%82%A8/"/>
    <url>/2023/09/27/%E6%AC%A2%E8%BF%8E%E6%82%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="欢迎来到苏禾的个人博客网站"><a href="#欢迎来到苏禾的个人博客网站" class="headerlink" title="欢迎来到苏禾的个人博客网站"></a>欢迎来到苏禾的个人博客网站</h1><p>友友们，大家好呀！🫶🫶🫶</p><p>感谢您百忙之中抽出宝贵的时间，来逛我的博客网站😝😝，既然来了先考大家一道Java题目吧，别打我😘😘😘</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Value</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">15</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span> &#123;<br><span class="hljs-type">Test</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test</span>();<br>        t.first();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">first</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br>        <span class="hljs-type">Value</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Value</span>();<br>        v.i = <span class="hljs-number">25</span>;<br>        second(v,i);<br>        System.out.println(v.i);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">second</span><span class="hljs-params">(Value v,<span class="hljs-type">int</span> i)</span> &#123;<br>        i = <span class="hljs-number">0</span>;<br>        v.i = <span class="hljs-number">20</span>;<br>        <span class="hljs-type">Value</span> <span class="hljs-variable">val</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Value</span>();<br>        v = val;<br>        System.out.println(v.i + <span class="hljs-string">&quot; &quot;</span> + i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>答案是：<code>15 0 20</code></p><p>聪明的你一定答对了吧！💮💮💮</p><p>到此为止，我就说说写这个博客网站的意义吧！！！🏝️🏝️🏝️</p><ul><li>首先我可以用这个记笔记 📝📝📝</li><li>其次可以和大家分享，交流，学习，共同进步 💪💪💪</li><li>最后，可以装x 🤪🤪🤪</li></ul><p>技术不精，可能网站还有很多问题，大家海涵！！！❤️❤️❤️</p>]]></content>
    
    
    
    <tags>
      
      <tag>WelCome</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
